buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath "io.swagger.codegen.v3:swagger-codegen:3.0.8"
    }
}

plugins {
    id "com.github.sherter.google-java-format" version "0.8"
    id "io.github.gradle-nexus.publish-plugin" version "1.0.0"
    id "maven"
    id "maven-publish"
    id "jacoco"
    id "java"
}

repositories {
    mavenLocal()
    mavenCentral()
}

sourceCompatibility = JavaVersion.VERSION_1_8

googleJavaFormat {
    toolVersion = '1.7'
}

ext {
    apiPackageAeternity = "com.kryptokrauts.aeternity.generated.api"
    modelPackageAeternity = "com.kryptokrauts.aeternity.generated.model"
    swaggerFileAeternity = "${rootDir}/api/swagger_aeternity.yml"

    apiPackageSophiaCompiler = "com.kryptokrauts.sophia.compiler.generated.api"
    modelPackageSophiaCompiler = "com.kryptokrauts.sophia.compiler.generated.model"
    swaggerFileSophiaCompiler = "${rootDir}/api/swagger_sophia_compiler.yml"

    apiPackageIndaex = "com.kryptokrauts.indaex.generated.api"
    modelPackageIndaex = "com.kryptokrauts.indaex.generated.model"
    swaggerFileIndaex = "${rootDir}/api/swagger_indaex.yml"

    templateDir = "${rootDir}/api/vertx-templates"
    swaggerAnnotationsVersion = "1.5.22"
    vertxVersion = "3.6.3"
    jacksonVersion = "2.9.8"

    lombokVersion = "1.18.10"

    bouncycastleVersion = "1.61"
    bitcoinjCoreVersion = "0.14.7"
    tuweniVersion = "0.8.2"

    junitVersion = "5.4.2"
    junitPlatformVersion = "1.4.2"
    spectrumVersion = "1.2.0"

    slf4jVersion = "1.7.26"
}

import io.swagger.codegen.DefaultGenerator
import io.swagger.codegen.config.CodegenConfigurator

def swaggerOutputDir = file("build/swagger")
task generateApiClient {
    doLast {
        def configAeternity = new CodegenConfigurator()
        configAeternity.setLang("java")
        configAeternity.setLibrary("vertx")
        configAeternity.setGroupId("${group}")
        configAeternity.setArtifactId("aeternity-client-vertx")
        configAeternity.setApiPackage("${apiPackageAeternity}")
        configAeternity.setModelPackage("${modelPackageAeternity}")
        configAeternity.setInputSpec(project.swaggerFileAeternity.toString())
        configAeternity.setOutputDir(swaggerOutputDir.path)
        configAeternity.setTemplateDir(project.templateDir)
        configAeternity.setAdditionalProperties([
                "dateLibrary": "java8",
                "title"      : rootProject.name,
                "useTags"    : "true"
        ])
        configAeternity.setTypeMappings([
                "Integer": "java.math.BigInteger"
        ])
        new DefaultGenerator().opts(configAeternity.toClientOptInput()).generate()

        def configSophiaCompiler = new CodegenConfigurator()
        configSophiaCompiler.setLang("java")
        configSophiaCompiler.setLibrary("vertx")
        configSophiaCompiler.setGroupId("${group}")
        configSophiaCompiler.setArtifactId("sophia-compiler-client-vertx")
        configSophiaCompiler.setApiPackage("${apiPackageSophiaCompiler}")
        configSophiaCompiler.setModelPackage("${modelPackageSophiaCompiler}")
        configSophiaCompiler.setInputSpec(project.swaggerFileSophiaCompiler.toString())
        configSophiaCompiler.setOutputDir(swaggerOutputDir.path)
        configSophiaCompiler.setTemplateDir(project.templateDir)
        configSophiaCompiler.setAdditionalProperties([
                "dateLibrary": "java8",
                "title"      : rootProject.name,
                "useTags"    : "true"
        ])
        new DefaultGenerator().opts(configSophiaCompiler.toClientOptInput()).generate()

        def configIndaex = new CodegenConfigurator()
        configIndaex.setLang("java")
        configIndaex.setLibrary("vertx")
        configIndaex.setGroupId("${group}")
        configIndaex.setArtifactId("indaex-client-vertx")
        configIndaex.setApiPackage("${apiPackageIndaex}")
        configIndaex.setModelPackage("${modelPackageIndaex}")
        configIndaex.setInputSpec(project.swaggerFileIndaex.toString())
        configIndaex.setOutputDir(swaggerOutputDir.path)
        configIndaex.setTemplateDir(project.templateDir)
        configIndaex.setAdditionalProperties([
                "dateLibrary": "java8",
                "title"      : rootProject.name,
                "useTags"    : "true"
        ])
        configIndaex.setTypeMappings([
                "Integer": "java.math.BigInteger"
        ])
        new DefaultGenerator().opts(configIndaex.toClientOptInput()).generate()

        // modify UnsignedTx
        ant.replaceregexp(match: '^.*\\b(JsonTypeInfo|JsonSubTypes)\\b.*$', replace: '', flags: 'g', byline: true) {
            fileset(dir: 'build/swagger/src/main/java/com/kryptokrauts/aeternity/generated/model', includes: 'UnsignedTx.java')
        }
        ant.replaceregexp(match: '\\}.*?\\)', replace: '', flags: 's') {
            fileset(dir: 'build/swagger/src/main/java/com/kryptokrauts/aeternity/generated/model', includes: 'UnsignedTx.java')
        }
    }
}

configurations {
    integrationTestCompile.extendsFrom testCompile
    integrationTestRuntime.extendsFrom testRuntime
    sharedCompile
}

sourceSets {
    swagger {
        java {
            srcDir file("${project.buildDir.path}/swagger/src/main/java")
        }
    }
    main {
        compileClasspath += swagger.output
        runtimeClasspath += swagger.output
    }
    test {
        compileClasspath += swagger.output
        runtimeClasspath += swagger.output
    }
    integrationTest {
        java {
            compileClasspath += main.output + test.output + swagger.output
            runtimeClasspath += main.output + test.output + swagger.output
            srcDir file("src/integrationTest/java")
        }
        resources.srcDir file("src/integrationTest/resources")
    }
}

task integrationTest(type: JavaExec, dependsOn: integrationTestClasses) {
    group = "Verification"
    description = "runs integration tests"
    classpath = sourceSets.integrationTest.runtimeClasspath
    main = "org.junit.platform.console.ConsoleLauncher"
    args = ["--scan-classpath", sourceSets.integrationTest.output.classesDirs.asPath,
            "--details", "tree",
            "--reports-dir", "${buildDir}/testResults/junit-integrationTest",
            "--fail-if-no-tests"]
}

final Boolean generateSources = Boolean.parseBoolean(System.getenv("AETERNITY_GENERATE_SOURCES"))
compileSwaggerJava {
    if (generateSources) {
        dependsOn(generateApiClient)
    }
    classpath = configurations.compile
}
compileJava {
    dependsOn(compileSwaggerJava)
    source += sourceSets.swagger.java
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

dependencies {
    // lombok
    compileOnly "org.projectlombok:lombok:${lombokVersion}"
    annotationProcessor "org.projectlombok:lombok:${lombokVersion}"

    // cryptography
    compile "org.bitcoinj:bitcoinj-core:${bitcoinjCoreVersion}"
    compile "org.bouncycastle:bcprov-jdk15on:${bouncycastleVersion}"
    compile "org.apache.tuweni:tuweni-rlp:${tuweniVersion}"
    compile "org.apache.tuweni:tuweni-crypto:${tuweniVersion}"
    compile "de.mkammerer:argon2-jvm:2.5"

    // needed for vertx client
    compile "io.swagger:swagger-annotations:${swaggerAnnotationsVersion}"
    compile "io.vertx:vertx-web-client:${vertxVersion}"
    compile "io.vertx:vertx-rx-java2:${vertxVersion}"
    compile "com.fasterxml.jackson.core:jackson-core:${jacksonVersion}"
    compile "com.fasterxml.jackson.core:jackson-annotations:${jacksonVersion}"
    compile "com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}"
    compile "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jacksonVersion}"

    // guava (we explicitely use this version to avoid loading wrong transitive dependency when using our SDK with maven)
    compile "com.google.guava:guava:27.0.1-jre"

    // tests
    testImplementation enforcedPlatform("org.junit:junit-bom:${junitVersion}")
    testRuntime "org.junit.platform:junit-platform-console:${junitPlatformVersion}"
    testRuntime "org.junit.jupiter:junit-jupiter-engine:${junitVersion}"
    testRuntime "org.junit.vintage:junit-vintage-engine:${junitVersion}"
    testCompile "org.junit.jupiter:junit-jupiter-api:${junitVersion}"
    testCompile "org.junit.jupiter:junit-jupiter-params:${junitVersion}"
    testCompile "org.junit.vintage:junit-vintage-engine:${junitVersion}"
    testCompile "commons-io:commons-io:2.6"
    testCompile "com.greghaskins:spectrum:${spectrumVersion}"
    testCompile "io.vertx:vertx-unit:${vertxVersion}"
    testCompile "io.vertx:vertx-junit5:${vertxVersion}"
    testCompile "org.junit.platform:junit-platform-launcher:${junitPlatformVersion}"
    testRuntime "org.slf4j:slf4j-simple:${slf4jVersion}"
}

test {
    dependsOn verifyGoogleJavaFormat
    finalizedBy jacocoTestReport
}

jacocoTestReport {
    dependsOn project*.test
    sourceSets sourceSets.main

    executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")

    reports {
        xml.enabled = true
        html.enabled = true
        html.destination file("${buildDir}/jacocoHtml")
    }
}

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

javadoc.failOnError = false
task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

artifacts {
    archives sourcesJar
    archives javadocJar
}

def pomConfig = {
    licenses {
        license {
            name "ISC License"
            url "https://opensource.org/licenses/isc-license.txt"
            distribution "repo"
        }
    }
    developers {
        developer {
            id "marc0olo"
            name "Marco Walz"
            email "walz.marcoo@gmail.com"
        }
        developer {
            id "mitch-lbw"
            name "Michel Meier"
            email "dna.fan@gmx.de"
        }
    }
    scm {
        url "https://github.com/${organization}/${project.name}"
    }
}

publishing {
    publications {
        mavenPublication(MavenPublication) {
            from components.java
            artifact sourcesJar {
                classifier "sources"
            }
            artifact javadocJar {
                classifier "javadoc"
            }
            groupId "${group}"
            artifactId project.name
            version project.version
            pom.withXml {
                def root = asNode()
                root.appendNode("description", "a community developed Java SDK to interact with the Ã¦ternity blockchain")
                root.appendNode("name", "${project.name}")
                root.appendNode("url", "https://github.com/${organization}/${project.name}")
                root.children().last() + pomConfig
            }
        }
    }
}

nexusPublishing {
    repositories {
        sonatype()
    }
}
