{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Getting started The aepp-sdk-java is a community developed Java SDK to interact with the \u00e6ternity blockchain powered by kryptokrauts.com ! System requirements Java 15 Sodium library Mac brew install libsodium Linux CentOS Enable EPEL run yum install libsodium Ubuntu / Debian apt-get install libsodium18 Windows get latest release libsodium download the latest pre-built binary (e.g. libsodium-1.0.18-msvc.zip ) extract libsodium.dll to C:\\Windows\\System32 Include dependency Release The latest release always reflects the state of the master branch. Maven <dependency> <groupId> com.kryptokrauts </groupId> <artifactId> aepp-sdk-java </artifactId> <version> 3.0.1 </version> </dependency> Gradle compile \"com.kryptokrauts:aepp-sdk-java:3.0.1\" Snapshot The latest snapshot always reflects the state of the 3.x branch. It is published with the version defined in gradle.properties . Maven <repositories> <repository> <id> maven-snapshots </id> <url> https://oss.sonatype.org/content/repositories/snapshots </url> </repository> </repositories> <dependencies> <dependency> <groupId> com.kryptokrauts </groupId> <artifactId> aepp-sdk-java </artifactId> <version> 3.0.2-SNAPSHOT </version> </dependency> </dependencies> Gradle repositories { jcenter() maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } } compile \"com.kryptokrauts:aepp-sdk-java:3.0.2-SNAPSHOT\"","title":"Getting Started"},{"location":"index.html#getting-started","text":"The aepp-sdk-java is a community developed Java SDK to interact with the \u00e6ternity blockchain powered by kryptokrauts.com !","title":"Getting started"},{"location":"index.html#system-requirements","text":"Java 15 Sodium library Mac brew install libsodium Linux CentOS Enable EPEL run yum install libsodium Ubuntu / Debian apt-get install libsodium18 Windows get latest release libsodium download the latest pre-built binary (e.g. libsodium-1.0.18-msvc.zip ) extract libsodium.dll to C:\\Windows\\System32","title":"System requirements"},{"location":"index.html#include-dependency","text":"","title":"Include dependency"},{"location":"index.html#release","text":"The latest release always reflects the state of the master branch.","title":"Release"},{"location":"index.html#maven","text":"<dependency> <groupId> com.kryptokrauts </groupId> <artifactId> aepp-sdk-java </artifactId> <version> 3.0.1 </version> </dependency>","title":"Maven"},{"location":"index.html#gradle","text":"compile \"com.kryptokrauts:aepp-sdk-java:3.0.1\"","title":"Gradle"},{"location":"index.html#snapshot","text":"The latest snapshot always reflects the state of the 3.x branch. It is published with the version defined in gradle.properties .","title":"Snapshot"},{"location":"index.html#maven_1","text":"<repositories> <repository> <id> maven-snapshots </id> <url> https://oss.sonatype.org/content/repositories/snapshots </url> </repository> </repositories> <dependencies> <dependency> <groupId> com.kryptokrauts </groupId> <artifactId> aepp-sdk-java </artifactId> <version> 3.0.2-SNAPSHOT </version> </dependency> </dependencies>","title":"Maven"},{"location":"index.html#gradle_1","text":"repositories { jcenter() maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } } compile \"com.kryptokrauts:aepp-sdk-java:3.0.2-SNAPSHOT\"","title":"Gradle"},{"location":"changelog.html","text":"Changelog v3.0.1 This is a minor release to address potential vulnerabilities in third party dependencies. It's highly recommended to update to this version. v3.0.0 This is a major release that underwent a huge refactoring. It supports the most important latest changes of aeternity. It is fully compatible with the latest Iris hardfork. General changes #196 , #218 , #219 , #220 , #221 , #222 , #223 SDK documentation via MkDocs including versioning with Mike #217 Improved Javadocs Updated dependencies Breaking changes #144 Revisited handling of keypairs: Introduced KeyPair class, dropped BaseKeyPair class Introduced HdWallet and HdKeyPair . These changes include a fix for a bug in the key derivation that derived wrong keypairs. #177 Discarded Java 8 in favor of Java 15+ #183 Middleware: dropped indaex (formerly aeternal ) in favor of mdw #206 Renamed gas to gasLimit in all transaction model classes New features #155 New transaction type PayingForTx #157 Arbitrary pointer-keys for AENS pointers #159 External (protected) dry-run endpoint #171 Convenient methods to create delegation signatures #184 Retrieve next nonce with new API endpoint that provides different strategies #188 Force deposit to be ZERO in ContractCreateTx #192 New method computeGAInnerTxHash for usage of Generalized Accounts #200 Limit max amount of pointers to 32. Introduce constant AENS.MAX_TTL . #201 Support for NameTransferTx #211 Convenient methods for contract related transaction types to easily: deploy a contract perform a stateful contract call perform a read-only dry-run call Refactoring #176 OpenAPI (OAS3) API ( /v3 ) in favor of old swagger API ( /v2 ) Introduced default values in the model classes of each tx-type v2.2.1 This release ships an enhancement. Enhancements #116 support includes for compiling, deploying and calling contracts we identified this was missing when developing the contraect-maven-plugin v2.2.0 This release ships some fixes and enhancements. Fixes #91 show exception details on compiler and aeternal errors #95 fix default values in BaseConstants Enhancements #96 add ResultWrapper for standard java types returned from service calls to omit exceptions being ignored #97 introduce configurable way to wait for tx being included in a block this is currently covered by the following properties and only relevant in blockingPostTransaction calls waitForTxIncludedInBlockEnabled (default=true) numTrialsToWaitForTxIncludedInBlock (default=60) millisBetweenTrialsToWaitForTxIncludedInBlock (default=1000) #98 provide a (more) user-friendly way to handle unit conversions we introduced a UnitConversionService -Interface with a DefaultUnitConversionService -Implementation that makes it a bit easier to handle conversions from AE to aettos or custom tokens that may have less decimals #99 prevent exceptions for TxModel classes #107 wait for confirmation of transaction now it is possible to wait for a transaction to be confirmed this is an asynchronous operation and can be configured through the following properties: numOfConfirmations (default=10) the number of confirmations (KeyBlocks) until a transaction is considered confirmed this value can also be explicitly set as method parameter millisBetweenTrailsToWaitForConfirmation (default=10000) #111 add \"payloadDecoded\" attribute to SpendTransactionModel now the payload for a SpendTx is automatically decoded v2.1.0 This release ships some fixes and enhancements. Additionally we renamed some attributes and model-classes. If you already used v2.0.0 it might be needed to fix these changes. Refactoring #86 add \"payable\" attribute to AccountResult-model Fixes #85 AeternalService: fix case-sensitive comparison of domains #88 replace Optional.orElse with Optional.orElseGet in the AccountServiceImpl Enhancements #84 add missing \u00c6NS related AeternalService functionalities we added the possibility to query for active names and search for a name (which allows to receive e.g. the owner of a name) #87 add support to receive byteCode for given contractId v2.0.0 Breaking changes and new features #77 integrate middleware aeternal and allow to query \u00c6NS auction related information #72 add method to post transactions with a custom private key #70 adapt TLD changes ( .chain instead of .aet ) #68 refactoring: rename contractBaseUrl to compilerBaseUrl #65 refactoring: allow posting of signed transactions (string) #64 \u00c6NS: auction-related functionalities calculate the next minimum fee for a running auction #63 refactoring: dryRun actions #56 Lima related changes: update to new node version v5.x.x \u00c6NS auctions: TLD: .aet instead of .test nameFee calculation adapt changes in generation of commitmentId and nameId update version of NameClaimTx update to new compiler version v4.x.x : adapt sophia contracts to compile with new version FATE-VM: make the compiler-backend configurable ( AEVM / FATE ) introduce VirtualMachine enum and add it to the ServiceConfiguration so that the services in the SDK use the correct vmVersion and abiVersion combination and the correct backend in the compiler #44 major refactoring: introduced model classes to be independent from the swagger-generated classes discarded the TransactionFactory -> for each transaction-type a model class was introduced which can be created following the builder-pattern introduced the AeternityService which serves as entrypoint to access other services and needs to be instantiated through the AeternityServiceFactory by passing the AeternityServiceConfiguration General changes #60 update tuweni to stable release version #57 support contracts and oracles as \u00c6NS pointers #49 provide guidelines for contributors #45 update of node ( v4.1.0 ) and compiler ( v3.2.0 ) v1.2.0 General changes #5 included a specific com.google.guava version ( 27.0.1-jre ) maven users shouldn't need to that in their own projects anymore #24 replaced net.consensys.cava dependency by org.apache.tuweni the project is now being maintained by the apache software foundation #25 upgraded SDK setup to make use of \u00e6ternity release 3.0.1 ( Fortuna ) #27 added goggles to docker-compose setup in order to enable easy tx verification in our local setup #31 we included our PaymentSplitter.aes contract into the test-resources and wrote an integration test to make sure our contract functionalities work #32 we made some changes regarding our release-notes in future you will find all information in this changelog-file there won't be a specific file for a certain release anymore #35 in future you will find the SDK documentation on gitbook: https://kryptokrauts.gitbook.io/aepp-sdk-java/ #36 upgraded SDK setup to make use of \u00e6ternity release 3.3.0 ( Fortuna ) New features #7 AENs support from now on it is possible to make use of the \u00e6ternity naming system #10 contract support from now on it is possible to create and interact with \u00e6ternity smart contracts while developing the contract support we identified some problems with the RLP encoding when trying to encode a BigInteger.ZERO in the past it wasn't possible to use a TTL with value 0 in any transaction type this is now solved :-) #28 added support for sophia compiler we now provide a CompilerServiceFactory that allows to get an Instance of SophiaCompilerServiceImpl this service was needed to enable creation of smart contracts with the SDK #40 added service method to generate ACI for Smart Contracts v1.1.0 Breaking changes Transactions are now created through a central TransactionFactory this refactoring breaks implementations that used older versions of the SDK General changes #13 upgrade to new \u00e6ternity release 2.0.0 ( Minerva ) New features #6 HD wallet support (BIP44, BIP32 + BIP39) it is now possible to create and recover HD wallets #11 Fees (gas cost) calculation \u00e6ternity release 2.0.0 ( Minerva ) introduced a new fee structure the SDK now provides an automated fee calculation if the user doesn't provide a fee on his/her own v1.0.2 Fixes #4 create a transaction on testnet we used ae_devnet instead of ae_uat before now we support 3 networks: DEVNET ( ae_devnet ) TESTNET ( ae_uat ) MAINNET ( ae_mainnet ) v1.0.1 General changes return Single instead of Observable for responses that return only one object switch from bouncycastle 1.61-beta to the release version (no more need to manually add it) v1.0.0 Initial release of our Java SDK to interact with the \u00e6ternity blockchain. Initial functionalities generate and recover KeyPair generate and recover Keystore-JSON create and sign spendTx various utils (crypto, encoding, signing)","title":"Changelog"},{"location":"changelog.html#changelog","text":"","title":"Changelog"},{"location":"changelog.html#v301","text":"This is a minor release to address potential vulnerabilities in third party dependencies. It's highly recommended to update to this version.","title":"v3.0.1"},{"location":"changelog.html#v300","text":"This is a major release that underwent a huge refactoring. It supports the most important latest changes of aeternity. It is fully compatible with the latest Iris hardfork.","title":"v3.0.0"},{"location":"changelog.html#general-changes","text":"#196 , #218 , #219 , #220 , #221 , #222 , #223 SDK documentation via MkDocs including versioning with Mike #217 Improved Javadocs Updated dependencies","title":"General changes"},{"location":"changelog.html#breaking-changes","text":"#144 Revisited handling of keypairs: Introduced KeyPair class, dropped BaseKeyPair class Introduced HdWallet and HdKeyPair . These changes include a fix for a bug in the key derivation that derived wrong keypairs. #177 Discarded Java 8 in favor of Java 15+ #183 Middleware: dropped indaex (formerly aeternal ) in favor of mdw #206 Renamed gas to gasLimit in all transaction model classes","title":"Breaking changes"},{"location":"changelog.html#new-features","text":"#155 New transaction type PayingForTx #157 Arbitrary pointer-keys for AENS pointers #159 External (protected) dry-run endpoint #171 Convenient methods to create delegation signatures #184 Retrieve next nonce with new API endpoint that provides different strategies #188 Force deposit to be ZERO in ContractCreateTx #192 New method computeGAInnerTxHash for usage of Generalized Accounts #200 Limit max amount of pointers to 32. Introduce constant AENS.MAX_TTL . #201 Support for NameTransferTx #211 Convenient methods for contract related transaction types to easily: deploy a contract perform a stateful contract call perform a read-only dry-run call","title":"New features"},{"location":"changelog.html#refactoring","text":"#176 OpenAPI (OAS3) API ( /v3 ) in favor of old swagger API ( /v2 ) Introduced default values in the model classes of each tx-type","title":"Refactoring"},{"location":"changelog.html#v221","text":"This release ships an enhancement.","title":"v2.2.1"},{"location":"changelog.html#enhancements","text":"#116 support includes for compiling, deploying and calling contracts we identified this was missing when developing the contraect-maven-plugin","title":"Enhancements"},{"location":"changelog.html#v220","text":"This release ships some fixes and enhancements.","title":"v2.2.0"},{"location":"changelog.html#fixes","text":"#91 show exception details on compiler and aeternal errors #95 fix default values in BaseConstants","title":"Fixes"},{"location":"changelog.html#enhancements_1","text":"#96 add ResultWrapper for standard java types returned from service calls to omit exceptions being ignored #97 introduce configurable way to wait for tx being included in a block this is currently covered by the following properties and only relevant in blockingPostTransaction calls waitForTxIncludedInBlockEnabled (default=true) numTrialsToWaitForTxIncludedInBlock (default=60) millisBetweenTrialsToWaitForTxIncludedInBlock (default=1000) #98 provide a (more) user-friendly way to handle unit conversions we introduced a UnitConversionService -Interface with a DefaultUnitConversionService -Implementation that makes it a bit easier to handle conversions from AE to aettos or custom tokens that may have less decimals #99 prevent exceptions for TxModel classes #107 wait for confirmation of transaction now it is possible to wait for a transaction to be confirmed this is an asynchronous operation and can be configured through the following properties: numOfConfirmations (default=10) the number of confirmations (KeyBlocks) until a transaction is considered confirmed this value can also be explicitly set as method parameter millisBetweenTrailsToWaitForConfirmation (default=10000) #111 add \"payloadDecoded\" attribute to SpendTransactionModel now the payload for a SpendTx is automatically decoded","title":"Enhancements"},{"location":"changelog.html#v210","text":"This release ships some fixes and enhancements. Additionally we renamed some attributes and model-classes. If you already used v2.0.0 it might be needed to fix these changes.","title":"v2.1.0"},{"location":"changelog.html#refactoring_1","text":"#86 add \"payable\" attribute to AccountResult-model","title":"Refactoring"},{"location":"changelog.html#fixes_1","text":"#85 AeternalService: fix case-sensitive comparison of domains #88 replace Optional.orElse with Optional.orElseGet in the AccountServiceImpl","title":"Fixes"},{"location":"changelog.html#enhancements_2","text":"#84 add missing \u00c6NS related AeternalService functionalities we added the possibility to query for active names and search for a name (which allows to receive e.g. the owner of a name) #87 add support to receive byteCode for given contractId","title":"Enhancements"},{"location":"changelog.html#v200","text":"","title":"v2.0.0"},{"location":"changelog.html#breaking-changes-and-new-features","text":"#77 integrate middleware aeternal and allow to query \u00c6NS auction related information #72 add method to post transactions with a custom private key #70 adapt TLD changes ( .chain instead of .aet ) #68 refactoring: rename contractBaseUrl to compilerBaseUrl #65 refactoring: allow posting of signed transactions (string) #64 \u00c6NS: auction-related functionalities calculate the next minimum fee for a running auction #63 refactoring: dryRun actions #56 Lima related changes: update to new node version v5.x.x \u00c6NS auctions: TLD: .aet instead of .test nameFee calculation adapt changes in generation of commitmentId and nameId update version of NameClaimTx update to new compiler version v4.x.x : adapt sophia contracts to compile with new version FATE-VM: make the compiler-backend configurable ( AEVM / FATE ) introduce VirtualMachine enum and add it to the ServiceConfiguration so that the services in the SDK use the correct vmVersion and abiVersion combination and the correct backend in the compiler #44 major refactoring: introduced model classes to be independent from the swagger-generated classes discarded the TransactionFactory -> for each transaction-type a model class was introduced which can be created following the builder-pattern introduced the AeternityService which serves as entrypoint to access other services and needs to be instantiated through the AeternityServiceFactory by passing the AeternityServiceConfiguration","title":"Breaking changes and new features"},{"location":"changelog.html#general-changes_1","text":"#60 update tuweni to stable release version #57 support contracts and oracles as \u00c6NS pointers #49 provide guidelines for contributors #45 update of node ( v4.1.0 ) and compiler ( v3.2.0 )","title":"General changes"},{"location":"changelog.html#v120","text":"","title":"v1.2.0"},{"location":"changelog.html#general-changes_2","text":"#5 included a specific com.google.guava version ( 27.0.1-jre ) maven users shouldn't need to that in their own projects anymore #24 replaced net.consensys.cava dependency by org.apache.tuweni the project is now being maintained by the apache software foundation #25 upgraded SDK setup to make use of \u00e6ternity release 3.0.1 ( Fortuna ) #27 added goggles to docker-compose setup in order to enable easy tx verification in our local setup #31 we included our PaymentSplitter.aes contract into the test-resources and wrote an integration test to make sure our contract functionalities work #32 we made some changes regarding our release-notes in future you will find all information in this changelog-file there won't be a specific file for a certain release anymore #35 in future you will find the SDK documentation on gitbook: https://kryptokrauts.gitbook.io/aepp-sdk-java/ #36 upgraded SDK setup to make use of \u00e6ternity release 3.3.0 ( Fortuna )","title":"General changes"},{"location":"changelog.html#new-features_1","text":"#7 AENs support from now on it is possible to make use of the \u00e6ternity naming system #10 contract support from now on it is possible to create and interact with \u00e6ternity smart contracts while developing the contract support we identified some problems with the RLP encoding when trying to encode a BigInteger.ZERO in the past it wasn't possible to use a TTL with value 0 in any transaction type this is now solved :-) #28 added support for sophia compiler we now provide a CompilerServiceFactory that allows to get an Instance of SophiaCompilerServiceImpl this service was needed to enable creation of smart contracts with the SDK #40 added service method to generate ACI for Smart Contracts","title":"New features"},{"location":"changelog.html#v110","text":"","title":"v1.1.0"},{"location":"changelog.html#breaking-changes_1","text":"Transactions are now created through a central TransactionFactory this refactoring breaks implementations that used older versions of the SDK","title":"Breaking changes"},{"location":"changelog.html#general-changes_3","text":"#13 upgrade to new \u00e6ternity release 2.0.0 ( Minerva )","title":"General changes"},{"location":"changelog.html#new-features_2","text":"#6 HD wallet support (BIP44, BIP32 + BIP39) it is now possible to create and recover HD wallets #11 Fees (gas cost) calculation \u00e6ternity release 2.0.0 ( Minerva ) introduced a new fee structure the SDK now provides an automated fee calculation if the user doesn't provide a fee on his/her own","title":"New features"},{"location":"changelog.html#v102","text":"","title":"v1.0.2"},{"location":"changelog.html#fixes_2","text":"#4 create a transaction on testnet we used ae_devnet instead of ae_uat before now we support 3 networks: DEVNET ( ae_devnet ) TESTNET ( ae_uat ) MAINNET ( ae_mainnet )","title":"Fixes"},{"location":"changelog.html#v101","text":"","title":"v1.0.1"},{"location":"changelog.html#general-changes_4","text":"return Single instead of Observable for responses that return only one object switch from bouncycastle 1.61-beta to the release version (no more need to manually add it)","title":"General changes"},{"location":"changelog.html#v100","text":"Initial release of our Java SDK to interact with the \u00e6ternity blockchain.","title":"v1.0.0"},{"location":"changelog.html#initial-functionalities","text":"generate and recover KeyPair generate and recover Keystore-JSON create and sign spendTx various utils (crypto, encoding, signing)","title":"Initial functionalities"},{"location":"contribute.html","text":"How to contribute? Get started Prerequisites Docker Gradle Lombok-Plugin The SDK heavily makes use of the lombok IDE plugin to hide glue code, especially getters, setters, builders and helper methods and helps to keep the classes clean and focus on the logic. The plugin is needed in your IDE of choice to automatically create the necessary methods in the background. System requirements Development environment To run integration tests you need to run the preconfigured docker setup by executing: docker-compose up -d You should see the following instances up and running: service description endpoints compiler Sophia http compiler that is required to compile contracts and to encode/decode calldata http://localhost:8080 node \u00e6ternity node including the middleware plugin http://localhost:3013 (node external api), http://localhost:3113 (node debug api), http://localhost:3014 (node websocket), http://localhost:4000 (middleware api), http://localhost:4001 (middleware websocket) proxy nginx proxy to access specific APIs without the need to provide a port http://localhost (node external & internal api), http://compiler.localhost (compiler), http://mdw.localhost (middleware) Generate API clients The SDK requires API clients (Compiler, Node & Middelware) that can be generated by executing following Gradle task: gradle generateApiClients Testing The SDK ships with two kinds of tests: unit tests , which run independently of a running node integration tests , which require a running aeternity node In order to run the integration tests you need to configure the following environment variables: AETERNITY_BASE_URL = http://localhost COMPILER_BASE_URL = http://localhost:3080 MDW_BASE_URL = http://localhost:4000 The tests can be run within your IDE of choice by using the following Gradle tasks: gradle test gradle integrationTest Integration tests should extend the BaseTest class which provides some convenient methods for running tests using the underlying vertx framework. Test methods can thus make use of the executeTest method as follows: @Test public void testMyLogic(TestContext context) { this.executeTest( context, t -> { ... context.assertEquals(\"test\", \"test\"); ... }); } Code format Before committing code you should make sure the code follows the Google Java Style. This can be done by executing: gradle googleJavaFormat Pull requests Please provide a pull request to the latest development branch, e.g. 3.x . We will review and merge or request some changes if neccesary. Make sure that the PR passes all the checks!","title":"Contribute"},{"location":"contribute.html#how-to-contribute","text":"","title":"How to contribute?"},{"location":"contribute.html#get-started","text":"","title":"Get started"},{"location":"contribute.html#prerequisites","text":"Docker Gradle Lombok-Plugin The SDK heavily makes use of the lombok IDE plugin to hide glue code, especially getters, setters, builders and helper methods and helps to keep the classes clean and focus on the logic. The plugin is needed in your IDE of choice to automatically create the necessary methods in the background. System requirements","title":"Prerequisites"},{"location":"contribute.html#development-environment","text":"To run integration tests you need to run the preconfigured docker setup by executing: docker-compose up -d You should see the following instances up and running: service description endpoints compiler Sophia http compiler that is required to compile contracts and to encode/decode calldata http://localhost:8080 node \u00e6ternity node including the middleware plugin http://localhost:3013 (node external api), http://localhost:3113 (node debug api), http://localhost:3014 (node websocket), http://localhost:4000 (middleware api), http://localhost:4001 (middleware websocket) proxy nginx proxy to access specific APIs without the need to provide a port http://localhost (node external & internal api), http://compiler.localhost (compiler), http://mdw.localhost (middleware)","title":"Development environment"},{"location":"contribute.html#generate-api-clients","text":"The SDK requires API clients (Compiler, Node & Middelware) that can be generated by executing following Gradle task: gradle generateApiClients","title":"Generate API clients"},{"location":"contribute.html#testing","text":"The SDK ships with two kinds of tests: unit tests , which run independently of a running node integration tests , which require a running aeternity node In order to run the integration tests you need to configure the following environment variables: AETERNITY_BASE_URL = http://localhost COMPILER_BASE_URL = http://localhost:3080 MDW_BASE_URL = http://localhost:4000 The tests can be run within your IDE of choice by using the following Gradle tasks: gradle test gradle integrationTest Integration tests should extend the BaseTest class which provides some convenient methods for running tests using the underlying vertx framework. Test methods can thus make use of the executeTest method as follows: @Test public void testMyLogic(TestContext context) { this.executeTest( context, t -> { ... context.assertEquals(\"test\", \"test\"); ... }); }","title":"Testing"},{"location":"contribute.html#code-format","text":"Before committing code you should make sure the code follows the Google Java Style. This can be done by executing: gradle googleJavaFormat","title":"Code format"},{"location":"contribute.html#pull-requests","text":"Please provide a pull request to the latest development branch, e.g. 3.x . We will review and merge or request some changes if neccesary. Make sure that the PR passes all the checks!","title":"Pull requests"},{"location":"example-apps.html","text":"Example applications In order to see the Java SDK in action you can check out following example applications that we created over time: aens-name-claimer This application can be used to claim and (auto-) extend multiple names. We used this application back then in 2019 to perform the first AENS claim ever on \u00e6ternity! ae-prediction-cards This application has been created during the Akshwani Haeck and has been awarded with Best \u00e6 oracles based DeFI application . aepp-showcase-android This is a very simple showcase how the SDK can be used in an Android application. contraect-showcase-maven This repository showcases how to use the contraect-maven-plugin to easily interact with smart contracts in Java. One of the examples is a MultiSig contract to be used with the Generalized Accounts feature. In addition to the examples above the Java SDK is being used to integrate \u00e6ternity into venly (formerly known as ArkaneNetwork) since early 2020! You can take a look at the implementation here .","title":"Example applications"},{"location":"example-apps.html#example-applications","text":"In order to see the Java SDK in action you can check out following example applications that we created over time: aens-name-claimer This application can be used to claim and (auto-) extend multiple names. We used this application back then in 2019 to perform the first AENS claim ever on \u00e6ternity! ae-prediction-cards This application has been created during the Akshwani Haeck and has been awarded with Best \u00e6 oracles based DeFI application . aepp-showcase-android This is a very simple showcase how the SDK can be used in an Android application. contraect-showcase-maven This repository showcases how to use the contraect-maven-plugin to easily interact with smart contracts in Java. One of the examples is a MultiSig contract to be used with the Generalized Accounts feature. In addition to the examples above the Java SDK is being used to integrate \u00e6ternity into venly (formerly known as ArkaneNetwork) since early 2020! You can take a look at the implementation here .","title":"Example applications"},{"location":"sdk-initialization.html","text":"Introduction The central access point to all services is made available through the AeternityService which can be obtained via the AeternityServiceFactory . Necessary parameters to for example identify the network to use or the endpoints to act against, are defined via the AeternityServiceConfiguration . Of course it is also possible to initialize each Service (such as AccountService or TransactionService ) independently by providing the required AeternityServiceConfiguration . Initialize AeternityService The following code-snippet is an example how to initialize the AeternityService with a KeyPair recovered from a known private key: KeyPairService keyPairService = new KeyPairServiceFactory (). getService (); KeyPair keyPair = keyPairService . recoverKeyPair ( < privateKey > ); AeternityService aeternityService = new AeternityServiceFactory () . getService ( AeternityServiceConfiguration . configure () . baseUrl ( < aeternityBaseUrl > ) . compilerBaseUrl ( < compilerBaseUrl > ) . mdwBaseUrl ( < mdwBaseUrl > ) . network ( Network . < network > ) . keyPair ( keyPair ) . compile ()); In many transaction models that you will build for the different transaction types that \u00e6ternity provides you will need to define the id of the sender or the account that performs the transaction. You can access the address of the KeyPair configured for the AeternityService easily by calling aeternityService.keyPairAddress . Service Configuration Within the AeternityServiceConfiguration class, different parameters can be set: Paramenter Description Default baseUrl endpoint of the aeternity node https://testnet.aeternity.io compilerBaseUrl endpoint of the Sophia http compiler https://compiler.aeternity.io debugBaseUrl debug endpoint of the aeternity node https://testnet.aeternity.io debugDryRun use debug dry-run endpoint instead of protected dry-run endpoint false defaultGasPrice default gas price to be used in contract related transactions 1000000000 dryRunGasReserveMargin the reserve margin to use for gasLimit in stateful contract calls (only relevant in the convenience method if dry-run is active) 1.25f dryRunStatefulCalls perform a dry-run for stateful contract calls by default (only relevant in the convenience method) true keyPair the KeyPair to use for signing transactions if no KeyPair is provided explicitly - mdwBaseUrl endpoint the aeternity middleware https://testnet.aeternity.io/mdw millisBetweenTrailsToWaitForConfirmation milliseconds to wait between trials for checking the confirmation 10000L millisBetweenTrialsToWaitForTxIncludedInBlock milliseconds to wait between trials for checking a tx to be included in a block 1000L nativeMode native mode builds transaction models with SDK. set to false to build via API call to node true network network to run against - should be aligned with endpoint of the node Network . TESTNET numOfConfirmations number of confirmations to wait for accepting a tx (relevance dependent on waitForTxIncludedInBlockEnabled ) 10 numTrialsToWaitForTxIncludedInBlock number of trials to wait for a tx to be included in a block (relevance dependent on waitForTxIncludedInBlockEnabled ) 60 targetVM the VM to target, since Iris only FATE is supported for new contracts VirtualMachine . FATE useZeroAddressAccountForDryRun use zero-address-account for dry-run true waitForTxIncludedInBlockEnabled wait for tx to be included in a block (only relevant in synchronous functions) true","title":"SDK initialization"},{"location":"sdk-initialization.html#introduction","text":"The central access point to all services is made available through the AeternityService which can be obtained via the AeternityServiceFactory . Necessary parameters to for example identify the network to use or the endpoints to act against, are defined via the AeternityServiceConfiguration . Of course it is also possible to initialize each Service (such as AccountService or TransactionService ) independently by providing the required AeternityServiceConfiguration .","title":"Introduction"},{"location":"sdk-initialization.html#initialize-aeternityservice","text":"The following code-snippet is an example how to initialize the AeternityService with a KeyPair recovered from a known private key: KeyPairService keyPairService = new KeyPairServiceFactory (). getService (); KeyPair keyPair = keyPairService . recoverKeyPair ( < privateKey > ); AeternityService aeternityService = new AeternityServiceFactory () . getService ( AeternityServiceConfiguration . configure () . baseUrl ( < aeternityBaseUrl > ) . compilerBaseUrl ( < compilerBaseUrl > ) . mdwBaseUrl ( < mdwBaseUrl > ) . network ( Network . < network > ) . keyPair ( keyPair ) . compile ()); In many transaction models that you will build for the different transaction types that \u00e6ternity provides you will need to define the id of the sender or the account that performs the transaction. You can access the address of the KeyPair configured for the AeternityService easily by calling aeternityService.keyPairAddress .","title":"Initialize AeternityService"},{"location":"sdk-initialization.html#service-configuration","text":"Within the AeternityServiceConfiguration class, different parameters can be set: Paramenter Description Default baseUrl endpoint of the aeternity node https://testnet.aeternity.io compilerBaseUrl endpoint of the Sophia http compiler https://compiler.aeternity.io debugBaseUrl debug endpoint of the aeternity node https://testnet.aeternity.io debugDryRun use debug dry-run endpoint instead of protected dry-run endpoint false defaultGasPrice default gas price to be used in contract related transactions 1000000000 dryRunGasReserveMargin the reserve margin to use for gasLimit in stateful contract calls (only relevant in the convenience method if dry-run is active) 1.25f dryRunStatefulCalls perform a dry-run for stateful contract calls by default (only relevant in the convenience method) true keyPair the KeyPair to use for signing transactions if no KeyPair is provided explicitly - mdwBaseUrl endpoint the aeternity middleware https://testnet.aeternity.io/mdw millisBetweenTrailsToWaitForConfirmation milliseconds to wait between trials for checking the confirmation 10000L millisBetweenTrialsToWaitForTxIncludedInBlock milliseconds to wait between trials for checking a tx to be included in a block 1000L nativeMode native mode builds transaction models with SDK. set to false to build via API call to node true network network to run against - should be aligned with endpoint of the node Network . TESTNET numOfConfirmations number of confirmations to wait for accepting a tx (relevance dependent on waitForTxIncludedInBlockEnabled ) 10 numTrialsToWaitForTxIncludedInBlock number of trials to wait for a tx to be included in a block (relevance dependent on waitForTxIncludedInBlockEnabled ) 60 targetVM the VM to target, since Iris only FATE is supported for new contracts VirtualMachine . FATE useZeroAddressAccountForDryRun use zero-address-account for dry-run true waitForTxIncludedInBlockEnabled wait for tx to be included in a block (only relevant in synchronous functions) true","title":"Service Configuration"},{"location":"usage-guides/aens.html","text":"\u00e6ternity naming system Introduction This guide shows you how to perform all the operations that you need within the lifecycle of \u00e6ternity naming system (AENS) using the SDK. The examples require you to have an initialized instance of AeternityService , see SDK initialization . If you successfully claimed a name it will expire after 180000 keyblocks (~375 days). You will need to update your name before it expires! 1. Claim a name Claiming an AENS name requires you (at least) 2 transactions: First you need to perform a pre-claim by providing a commitmentId (hash). The commitmentId is calculated with a random salt and the provided name. The SDK automatically generates the random salt , calculates the commitmentId and includes it into the NamePreclaimTx . After the NamePreclaimTx transaction has been mined you will be able to perform the actual claim of the name. When performing the actual claim via a NameClaimTx you will, depending on the length of the name: immediately become owner of that name initiate an auction Pre-claim BigInteger salt = CryptoUtils . generateNamespaceSalt (); NamePreclaimTransactionModel preClaimTx = NamePreclaimTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) . name ( \"userguide.chain\" ) . salt ( salt ) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); // the tx will be automatically signed and broadcasted using the configured KeyPair PostTransactionResult preClaimTxResult = aeternityService . transactions . blockingPostTransaction ( preClaimTx ); Note: After transaction is included, you have 300 keyblocks to broadcast claim transaction with the same salt and it should be signed with the same private key as pre-claim . As the pre-claim is required to avoid front running it is recommended to wait with the actual claim until at least 1 keyblock has been mined so that nobody knows which name you aim to claim. The corresponding claim cannot be included in the same keyblock anyway. The protocol doesn't allow that. You should check if the name is still available before performing a pre-claim . The protocol itself doesn't reject a pre-claim transaction if the name isn't available anymore. As you can see above in the logs the result ( preClaimTx ) of the aensPreclaim has bound a claim function that you can make use of to perform the actual claim. In case you want to perform the actual claim at a later point you should remember the salt that has been used for the pre-claim Claim // re-use the salt from the pre-claim here NameClaimTransactionModel nameClaimTx = NameClaimTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) . name ( \"userguide.chain\" ) . nameSalt ( salt ) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); // the tx will be automatically signed and broadcasted using the configured KeyPair PostTransactionResult nameClaimTxResult = aeternityService . transactions . blockingPostTransaction ( nameClaimTx ); Note: The nameFee that is required will be correctly calculated automatically for the initial claim. You can also set it manually but this is only required in running auctions (see below) In case the claim triggers an auction the required nameFee is locked by the protocol. If you win the auction the nameFee is permanently deducted from your accounts balance and effectively burned . It will be credited to ak_11111111111111111111111111111111273Yts which nobody can access. This reduces the total supply of AE over time. If somebody else outbids you the provided nameFee is immediately released and returned to your account. Bid during an auction In case there is an auction running for a name you want to claim you need to place a bid. Get the info about a running auction via middleware // get auction information NameAuctionResult nameAuctionResult = aeternityService . mdw . blockingGetNameAuction ( \"auction.chain\" ); // calculate the minimum required fee for the next bid BigInteger minimumNextFee = AENS . getNextNameFee ( nameAuctionResult . getCurrentBid (). getNameFee ()); // build, sign & broadcast the bid (NameClaimTx) NameClaimTransactionModel nameClaimTx = NameClaimTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) . name ( \"userguide.chain\" ) . nameSalt ( BigInteger . ZERO ) // for bids this value needs to be set to ZERO . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); // the tx will be automatically signed and broadcasted using the configured KeyPair PostTransactionResult nameClaimTxResult = aeternityService . transactions . blockingPostTransaction ( nameClaimTx ); 2. Update a name Now that you own your AENS name you might want to update it in order to: Set pointers to accounts , oracles , contracts or channels . Extend the TTL before it expires. By default a name will have a TTL of 180000 keyblocks (~375 days). It cannot be extended longer than 180000 keyblocks. // fake other allowed pointers for some KeyPair KeyPair someKeyPair = keyPairService . generateKeyPair (); String contractPointer = keyPair . getContractAddress (); String channelPointer = keyPair . getAddress (). replace ( \"ak_\" , \"ch_\" ); String oraclePointer = keyPair . getOracleAddress (); // generate another KeyPair for other pointers KeyPair anotherKeyPair = keyPairService . generateKeyPair (); // build the NameUpdateTransactionModel NameUpdateTransactionModel nameUpdateTx = NameUpdateTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) // this account must be owner of the name . nameId ( AENS . getNameId ( \"userguide.chain\" )) // get the correct nameId for a name . pointers ( new HashMap < String , String > () { { put ( AENS . POINTER_KEY_ACCOUNT , accountPointer ); // default pointer-key for accounts put ( AENS . POINTER_KEY_CHANNEL , channelPointer ); // default pointer-key for channels put ( AENS . POINTER_KEY_CONTRACT , contractPointer ); // default pointer-key for contracts put ( AENS . POINTER_KEY_ORACLE , oraclePointer ); // default pointer-key for oracles put ( \"arbitrary-account-pointer-key\" , anotherKeyPair . getAddress ()); put ( \"arbitrary-channel-pointer-key\" , // workaround to set a valid channel id anotherKeyPair . getAddress (). replace ( \"ak_\" , \"ch_\" )); put ( \"arbitrary-contract-pointer-key\" , anotherKeyPair . getContractAddress ()); put ( \"arbitrary-oracle-pointer-key\" , anotherKeyPair . getOracleAddress ()); } }) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); PostTransactionResult nameUpdateTxResult = aeternityService . transactions . blockingPostTransaction ( nameUpdateTx ); Note: You can set up to 32 pointers in total for each name. The name will be extended for AENS.MAX_TTL (180000) by default. 3. Transfer ownership of a name In some cases you might want to transfer the ownership of a name to another account. Of course this is also possible and you can do that as follows: // we select a random new owner KeyPair newOwnerKeyPair = keyPairService . generateKeyPair (); NameTransferTransactionModel nameTransferTx = NameTransferTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) // this account must be owner of the name . nameId ( AENS . getNameId ( \"userguide.chain\" )) // get the correct nameId for a name . recipientId ( newOwnerKeyPair . getAddress ()) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); PostTransactionResult nameTransferTxResult = aeternityService . transactions . blockingPostTransaction ( nameTransferTx ); 4. Revoke a name In case you want to revoke a name prior to its expiration for whatever reason you can do that as follows: NameRevokeTransactionModel nameRevokeTx = NameRevokeTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) // this account must be owner of the name . nameId ( AENS . getNameId ( \"userguide.chain\" )) // get the correct nameId for a name . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); PostTransactionResult nameRevokeTxResult = aeternityService . transactions . blockingPostTransaction ( nameRevokeTx ); Note: On revocation the name enters in a revoked state. After a timeout of 2016 keyblocks the name will be available for claiming again. Delegate signature to contract (AENS interface) It is possible to authorize a Sophia contract to manage an AENS name on behalf of your account. In order to achieve that you need to provide a delegation signature to the contract. The contract will then be able to use the AENS interface and perform AENS related actions on behalf of your account. This functionality could for example be used to build an AENS marketplace. The DelegationService can be used to produce the signatures that can be used to delegate control for certain actions to a smart contract. Examples how to delegate signatures to a contract can be found in our contract-maven-showcase .","title":"\u00e6ternity naming system"},{"location":"usage-guides/aens.html#ternity-naming-system","text":"","title":"\u00e6ternity naming system"},{"location":"usage-guides/aens.html#introduction","text":"This guide shows you how to perform all the operations that you need within the lifecycle of \u00e6ternity naming system (AENS) using the SDK. The examples require you to have an initialized instance of AeternityService , see SDK initialization . If you successfully claimed a name it will expire after 180000 keyblocks (~375 days). You will need to update your name before it expires!","title":"Introduction"},{"location":"usage-guides/aens.html#1-claim-a-name","text":"Claiming an AENS name requires you (at least) 2 transactions: First you need to perform a pre-claim by providing a commitmentId (hash). The commitmentId is calculated with a random salt and the provided name. The SDK automatically generates the random salt , calculates the commitmentId and includes it into the NamePreclaimTx . After the NamePreclaimTx transaction has been mined you will be able to perform the actual claim of the name. When performing the actual claim via a NameClaimTx you will, depending on the length of the name: immediately become owner of that name initiate an auction","title":"1. Claim a name"},{"location":"usage-guides/aens.html#pre-claim","text":"BigInteger salt = CryptoUtils . generateNamespaceSalt (); NamePreclaimTransactionModel preClaimTx = NamePreclaimTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) . name ( \"userguide.chain\" ) . salt ( salt ) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); // the tx will be automatically signed and broadcasted using the configured KeyPair PostTransactionResult preClaimTxResult = aeternityService . transactions . blockingPostTransaction ( preClaimTx ); Note: After transaction is included, you have 300 keyblocks to broadcast claim transaction with the same salt and it should be signed with the same private key as pre-claim . As the pre-claim is required to avoid front running it is recommended to wait with the actual claim until at least 1 keyblock has been mined so that nobody knows which name you aim to claim. The corresponding claim cannot be included in the same keyblock anyway. The protocol doesn't allow that. You should check if the name is still available before performing a pre-claim . The protocol itself doesn't reject a pre-claim transaction if the name isn't available anymore. As you can see above in the logs the result ( preClaimTx ) of the aensPreclaim has bound a claim function that you can make use of to perform the actual claim. In case you want to perform the actual claim at a later point you should remember the salt that has been used for the pre-claim","title":"Pre-claim"},{"location":"usage-guides/aens.html#claim","text":"// re-use the salt from the pre-claim here NameClaimTransactionModel nameClaimTx = NameClaimTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) . name ( \"userguide.chain\" ) . nameSalt ( salt ) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); // the tx will be automatically signed and broadcasted using the configured KeyPair PostTransactionResult nameClaimTxResult = aeternityService . transactions . blockingPostTransaction ( nameClaimTx ); Note: The nameFee that is required will be correctly calculated automatically for the initial claim. You can also set it manually but this is only required in running auctions (see below) In case the claim triggers an auction the required nameFee is locked by the protocol. If you win the auction the nameFee is permanently deducted from your accounts balance and effectively burned . It will be credited to ak_11111111111111111111111111111111273Yts which nobody can access. This reduces the total supply of AE over time. If somebody else outbids you the provided nameFee is immediately released and returned to your account.","title":"Claim"},{"location":"usage-guides/aens.html#bid-during-an-auction","text":"In case there is an auction running for a name you want to claim you need to place a bid. Get the info about a running auction via middleware // get auction information NameAuctionResult nameAuctionResult = aeternityService . mdw . blockingGetNameAuction ( \"auction.chain\" ); // calculate the minimum required fee for the next bid BigInteger minimumNextFee = AENS . getNextNameFee ( nameAuctionResult . getCurrentBid (). getNameFee ()); // build, sign & broadcast the bid (NameClaimTx) NameClaimTransactionModel nameClaimTx = NameClaimTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) . name ( \"userguide.chain\" ) . nameSalt ( BigInteger . ZERO ) // for bids this value needs to be set to ZERO . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); // the tx will be automatically signed and broadcasted using the configured KeyPair PostTransactionResult nameClaimTxResult = aeternityService . transactions . blockingPostTransaction ( nameClaimTx );","title":"Bid during an auction"},{"location":"usage-guides/aens.html#2-update-a-name","text":"Now that you own your AENS name you might want to update it in order to: Set pointers to accounts , oracles , contracts or channels . Extend the TTL before it expires. By default a name will have a TTL of 180000 keyblocks (~375 days). It cannot be extended longer than 180000 keyblocks. // fake other allowed pointers for some KeyPair KeyPair someKeyPair = keyPairService . generateKeyPair (); String contractPointer = keyPair . getContractAddress (); String channelPointer = keyPair . getAddress (). replace ( \"ak_\" , \"ch_\" ); String oraclePointer = keyPair . getOracleAddress (); // generate another KeyPair for other pointers KeyPair anotherKeyPair = keyPairService . generateKeyPair (); // build the NameUpdateTransactionModel NameUpdateTransactionModel nameUpdateTx = NameUpdateTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) // this account must be owner of the name . nameId ( AENS . getNameId ( \"userguide.chain\" )) // get the correct nameId for a name . pointers ( new HashMap < String , String > () { { put ( AENS . POINTER_KEY_ACCOUNT , accountPointer ); // default pointer-key for accounts put ( AENS . POINTER_KEY_CHANNEL , channelPointer ); // default pointer-key for channels put ( AENS . POINTER_KEY_CONTRACT , contractPointer ); // default pointer-key for contracts put ( AENS . POINTER_KEY_ORACLE , oraclePointer ); // default pointer-key for oracles put ( \"arbitrary-account-pointer-key\" , anotherKeyPair . getAddress ()); put ( \"arbitrary-channel-pointer-key\" , // workaround to set a valid channel id anotherKeyPair . getAddress (). replace ( \"ak_\" , \"ch_\" )); put ( \"arbitrary-contract-pointer-key\" , anotherKeyPair . getContractAddress ()); put ( \"arbitrary-oracle-pointer-key\" , anotherKeyPair . getOracleAddress ()); } }) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); PostTransactionResult nameUpdateTxResult = aeternityService . transactions . blockingPostTransaction ( nameUpdateTx ); Note: You can set up to 32 pointers in total for each name. The name will be extended for AENS.MAX_TTL (180000) by default.","title":"2. Update a name"},{"location":"usage-guides/aens.html#3-transfer-ownership-of-a-name","text":"In some cases you might want to transfer the ownership of a name to another account. Of course this is also possible and you can do that as follows: // we select a random new owner KeyPair newOwnerKeyPair = keyPairService . generateKeyPair (); NameTransferTransactionModel nameTransferTx = NameTransferTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) // this account must be owner of the name . nameId ( AENS . getNameId ( \"userguide.chain\" )) // get the correct nameId for a name . recipientId ( newOwnerKeyPair . getAddress ()) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); PostTransactionResult nameTransferTxResult = aeternityService . transactions . blockingPostTransaction ( nameTransferTx );","title":"3. Transfer ownership of a name"},{"location":"usage-guides/aens.html#4-revoke-a-name","text":"In case you want to revoke a name prior to its expiration for whatever reason you can do that as follows: NameRevokeTransactionModel nameRevokeTx = NameRevokeTransactionModel . builder () . accountId ( aeternityService . keyPairAddress ) // this account must be owner of the name . nameId ( AENS . getNameId ( \"userguide.chain\" )) // get the correct nameId for a name . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); PostTransactionResult nameRevokeTxResult = aeternityService . transactions . blockingPostTransaction ( nameRevokeTx ); Note: On revocation the name enters in a revoked state. After a timeout of 2016 keyblocks the name will be available for claiming again.","title":"4. Revoke a name"},{"location":"usage-guides/aens.html#delegate-signature-to-contract-aens-interface","text":"It is possible to authorize a Sophia contract to manage an AENS name on behalf of your account. In order to achieve that you need to provide a delegation signature to the contract. The contract will then be able to use the AENS interface and perform AENS related actions on behalf of your account. This functionality could for example be used to build an AENS marketplace. The DelegationService can be used to produce the signatures that can be used to delegate control for certain actions to a smart contract. Examples how to delegate signatures to a contract can be found in our contract-maven-showcase .","title":"Delegate signature to contract (AENS interface)"},{"location":"usage-guides/contracts.html","text":"Contracts Introduction The smart contract language of the \u00e6ternity blockchain is Sophia . It is a functional language in the ML family, strongly typed and has restricted mutable state. Before interacting with contracts using the SDK you should get familiar with Sophia itself first. Have a look into aepp-sophia-examples and start rapid prototyping using AEstudio . The SDK needs to interact with following components in order to enable smart contract interactions on the \u00e6ternity blockchain: \u00e6ternity (host your own one or use the public testnet node at https://testnet.aeternity.io ) aesophia_http (host your own one or use the public compiler at https://compiler.aepps.com ) Note: For production deployments you should always host these services by yourself. We highly recommend the usage of the contraect-maven-plugin for smart contract interaction. Contract interaction For the example interaction following contract is being used: @ compiler >= 6 include \"String.aes\" contract ChatBot = record state = { last_name : string } datatype event = Greeting ( string ) entrypoint init () = { last_name = \"\" } entrypoint greet ( name : string ) : string = Chain . event ( Greeting ( name )) String . concat ( \"Hello, \" , name ) stateful entrypoint greet_and_remember ( name : string ) : string = Chain . event ( Greeting ( name )) put ( state { last_name = name }) String . concat ( \"Hello, \" , name ) Compile a contract By using the CompilerService you can easily interact with the hosted Sophia http compiler and get the bytecode in return. String sourceCode = \"...\" ; // use source code of ChatBot contract String bytecode = aeternityService . compiler . blockingCompile ( sourceCode , null ) . getResult (); Handle includes In case your contract contains custom includes (contracts/interfaces placed in other files) you need to provide a map in the fileSystem param with the name of the include as key and the source code of the include as value. Deploy a contract When you have the bytecode you are basically ready to deploy the contract. This example contract doesn't expect any param in the init method. In this case you don't have to use the CompilerService to encode the calldata. You can simply use a default constant for the empty calldata. Convenient way ContractTxResult contractTxResult = aeternityService . transactions . blockingContractCreate ( sourceCode ); String contractId = contractTxResult . getCallResult (). getContractId (); Explicit way // build the tx model with all the required attributes ContractCreateTransactionModel contractCreate = ContractCreateTransactionModel . builder () // in case the init entrypoint doesn't require a param you can simply use this constant value . callData ( BaseConstants . CONTRACT_EMPTY_INIT_CALLDATA ) . contractByteCode ( byteCode ) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . ownerId ( aeternityService . keyPairAddress ) . build (); // by default this action will wait until the tx is included in a block) PostTransactionResult createTxResult = aeternityService . transactions . blockingPostTransaction ( contractCreate ); // after the tx is included you can fetch the tx-info to determine the contractId TransactionInfoResult createTxInfoResult = aeternityService . info . blockingGetTransactionInfoByHash ( createTxResult . getTxHash ()); String contractId = createTxInfoResult . getCallInfo (). getContractId (); Call a contract (read-only) Convenient way AeternityService readOnlyService = new AeternityServiceFactory (). getService (); Object decodedResult = readOnlyService . transactions . blockingReadOnlyContractCall ( contractId , \"greet\" , sourceCode , ContractTxOptions . builder () . params ( List . of ( new SophiaString ( \"kryptokrauts\" ))) . build ()); log . info ( decodedResult . toString ()); // \"Hello, kryptokrauts\" Explicit way AeternityService readOnlyService = new AeternityServiceFactory (). getService (); String callData = readOnlyService . compiler . blockingEncodeCalldata ( sourceCode , \"greet\" , Arrays . asList ( \"\\\"kryptokrauts\\\"\" ), null ) . getResult (); ContractCallTransactionModel contractCall = ContractCallTransactionModel . builder () . contractId ( contractId ) . callData ( callData ) . build (); DryRunTransactionResult dryRunResult = readOnlyService . transactions . blockingDryRunContractTx ( contractCall , true ); ObjectResultWrapper resultWrapper = readOnlyService . compiler . blockingDecodeCallResult ( sourceCode , \"greet\" , dryRunResult . getContractCallObject (). getReturnType (), dryRunResult . getContractCallObject (). getReturnValue (), null ); log . info ( resultWrapper . getResult (). toString ()); // \"Hello, kryptokrauts\" Call a contract (stateful) Convenient way When using the convenient way by calling blockingStatefulContractCall you will receive an object ContractTxResult which includes all important information (e.g. tx-hash, gas used, ...) about the stateful contract call. ContractTxResult contractTxResult = aeternityService . transactions . blockingStatefulContractCall ( contractId , \"greet_and_remember\" , sourceCode , ContractTxOptions . builder () . params ( List . of ( new SophiaString ( \"kryptokrauts\" ))) . build ()); Explicit way // obtain the calldata by calling the http compiler String callData = aeternityService . compiler . blockingEncodeCalldata ( chatBotSource , \"greet_and_remember\" , Arrays . asList ( \"\\\"kryptokrauts\\\"\" ), null ) . getResult (); // build the contract call tx model ContractCallTransactionModel contractCall = ContractCallTransactionModel . builder () . callerId ( aeternityService . keyPairAddress ) . contractId ( contractId ) . callData ( callData ) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); /** * optional: if you know that the default of 25000 is sufficient you don't need a dry-run at all */ DryRunTransactionResult dryRunResult = aeternityService . transactions . blockingDryRunContractTx ( contractCall , false ); /** * determine gasUsed via dry-run and add a margin to make sure the tx gets mined. * ideally you implement this as a one-time action and monitor gas usage over time. * the margin is not required but recommended. if the provided gasLimit is insufficient * the tx will fail and consumed gas will be payed anyway. so you can lose funds */ BigInteger gasLimitWithMargin = new BigDecimal ( dryRunResult . getContractCallObject (). getGasUsed ()) . multiply ( new BigDecimal ( 1.5f )) . toBigInteger (); // set the gasLimitWithMargin before broadcasting the transaction contractCall = contractCall . toBuilder (). gasLimit ( gasLimitWithMargin ). build (); // broadcast the tx PostTransactionResult txResult = aeternityService . transactions . blockingPostTransaction ( contractCall ); // obtain the tx-info TransactionInfoResult infoResult = aeternityService . info . blockingGetTransactionInfoByHash ( txResult . getTxHash ()); // decode the return value by calling the http compiler ObjectResultWrapper resultWrapper = aeternityService . compiler . blockingDecodeCallResult ( chatBotSource , \"greet_and_remember\" , infoResult . getCallInfo (). getReturnType (), infoResult . getCallInfo (). getReturnValue (), null ); _logger . info ( resultWrapper . getResult (). toString ()); // \"Hello, kryptokrauts\" Additional topics Gas estimation via dry-run It is reasonable to estimate the gas consumption for a contract call using the dry-run feature of the node at least once and provide a specific offset (e.g. multiplied by 1.25 or 2) as default to ensure that contract calls are mined. Depending on the logic of the contract the gas consumption of a specific contract call can vary and therefore you should monitor the gas consumption and increase the default for the respective contract call accordingly over time. The default gas value of 25000 should cover all trivial stateful contract calls. In case transactions start running out of gas you should proceed the way described above and estimate the required gas using the dry-run feature. ContractTxOptions In the convenience methods you can always provide tx-options and define some or all of following attributes: params (the list of params to be passed, default: null ) check the Sophia type-mapping table below amount (the amount in \u00e6ttos to be passed, default ZERO ) gasLimit (the custom gasLimit, default: 25000 ) gasPrice (the custom gasPrice to be used in the tx instead of the default 1000000000 ) nonce (the custom nonce to be used in the tx, default: automatically determined by the sdk) ttl (the custom ttl, default: ZERO ) filesystem (the includes-map for the contract, default: null ) key = include-name value = source code of the include Sophia type-mapping The following mapping table indicates what Java types have to be passed for the respective Sophia entrypoint parameters. If you use the convenience methods you only need to make sure the params reflect the required types in Sophia. The convenience methods use the toCompilerInput method of SophiaTypeTransformer to automatically transform the Java type into the representation the Sophia compiler expects it to be. The reverse mapping not fully covered by the SDK. You need to analyze the result object and map/handle it accordingly. For some types there is also a reverse mapping implemented. To make use of this you have to call the getMappedResult method of the SophiaTypeTransformer and provide the expected type explicitely. If want full type support, please refer to the contraect-maven-plugin which will generate a class out of your contract with all types and methods under the hood to easily interact with your contract. Sophia type Java type Sophia example value address String ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt bool Boolean true , false bytes(8) SophiaBytes #fedcba9876543210 Chain.ttl SophiaChainTTL FixedTTL(1050) , RelativeTTL(50) contract String ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ hash SophiaHash #000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f int Integer / Long / BigInteger 1337 , 1337 list(string) List<SophiaString> [\"a\", \"b\", \"c\"] map(string, string) Map<SophiaString, SophiaString> {[\"foo\"] = \"bar\", [\"x\"] = \"yz\"} option(string) Optional<SophiaString> Some(\"kryptokrauts\") , None oracle('a, 'b) String ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5 oracle_query('a, 'b) String oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY signature SophiaSignature #000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f string SophiaString \"This is a string\" tuple SophiaTuple (42, \"Foo\", true) Plugins contraect-maven-plugin To provide an even more convenient way to interact with smart contracts on the \u00e6ternity blockchain we developed a plugin that uses the ACI of contracts written in Sophia as input to generate Java classes. The generated classes make use of the aepp-sdk-java and provide methods to deploy contracts and call the respective entrypoint functions. In contrast to plain SDK usage the plugin provides you type-safe param and return values. Links : https://github.com/kryptokrauts/contraect-maven-plugin https://github.com/kryptokrauts/contraect-showcase-maven","title":"Contracts"},{"location":"usage-guides/contracts.html#contracts","text":"","title":"Contracts"},{"location":"usage-guides/contracts.html#introduction","text":"The smart contract language of the \u00e6ternity blockchain is Sophia . It is a functional language in the ML family, strongly typed and has restricted mutable state. Before interacting with contracts using the SDK you should get familiar with Sophia itself first. Have a look into aepp-sophia-examples and start rapid prototyping using AEstudio . The SDK needs to interact with following components in order to enable smart contract interactions on the \u00e6ternity blockchain: \u00e6ternity (host your own one or use the public testnet node at https://testnet.aeternity.io ) aesophia_http (host your own one or use the public compiler at https://compiler.aepps.com ) Note: For production deployments you should always host these services by yourself. We highly recommend the usage of the contraect-maven-plugin for smart contract interaction.","title":"Introduction"},{"location":"usage-guides/contracts.html#contract-interaction","text":"For the example interaction following contract is being used: @ compiler >= 6 include \"String.aes\" contract ChatBot = record state = { last_name : string } datatype event = Greeting ( string ) entrypoint init () = { last_name = \"\" } entrypoint greet ( name : string ) : string = Chain . event ( Greeting ( name )) String . concat ( \"Hello, \" , name ) stateful entrypoint greet_and_remember ( name : string ) : string = Chain . event ( Greeting ( name )) put ( state { last_name = name }) String . concat ( \"Hello, \" , name )","title":"Contract interaction"},{"location":"usage-guides/contracts.html#compile-a-contract","text":"By using the CompilerService you can easily interact with the hosted Sophia http compiler and get the bytecode in return. String sourceCode = \"...\" ; // use source code of ChatBot contract String bytecode = aeternityService . compiler . blockingCompile ( sourceCode , null ) . getResult ();","title":"Compile a contract"},{"location":"usage-guides/contracts.html#handle-includes","text":"In case your contract contains custom includes (contracts/interfaces placed in other files) you need to provide a map in the fileSystem param with the name of the include as key and the source code of the include as value.","title":"Handle includes"},{"location":"usage-guides/contracts.html#deploy-a-contract","text":"When you have the bytecode you are basically ready to deploy the contract. This example contract doesn't expect any param in the init method. In this case you don't have to use the CompilerService to encode the calldata. You can simply use a default constant for the empty calldata.","title":"Deploy a contract"},{"location":"usage-guides/contracts.html#convenient-way","text":"ContractTxResult contractTxResult = aeternityService . transactions . blockingContractCreate ( sourceCode ); String contractId = contractTxResult . getCallResult (). getContractId ();","title":"Convenient way"},{"location":"usage-guides/contracts.html#explicit-way","text":"// build the tx model with all the required attributes ContractCreateTransactionModel contractCreate = ContractCreateTransactionModel . builder () // in case the init entrypoint doesn't require a param you can simply use this constant value . callData ( BaseConstants . CONTRACT_EMPTY_INIT_CALLDATA ) . contractByteCode ( byteCode ) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . ownerId ( aeternityService . keyPairAddress ) . build (); // by default this action will wait until the tx is included in a block) PostTransactionResult createTxResult = aeternityService . transactions . blockingPostTransaction ( contractCreate ); // after the tx is included you can fetch the tx-info to determine the contractId TransactionInfoResult createTxInfoResult = aeternityService . info . blockingGetTransactionInfoByHash ( createTxResult . getTxHash ()); String contractId = createTxInfoResult . getCallInfo (). getContractId ();","title":"Explicit way"},{"location":"usage-guides/contracts.html#call-a-contract-read-only","text":"","title":"Call a contract (read-only)"},{"location":"usage-guides/contracts.html#convenient-way_1","text":"AeternityService readOnlyService = new AeternityServiceFactory (). getService (); Object decodedResult = readOnlyService . transactions . blockingReadOnlyContractCall ( contractId , \"greet\" , sourceCode , ContractTxOptions . builder () . params ( List . of ( new SophiaString ( \"kryptokrauts\" ))) . build ()); log . info ( decodedResult . toString ()); // \"Hello, kryptokrauts\"","title":"Convenient way"},{"location":"usage-guides/contracts.html#explicit-way_1","text":"AeternityService readOnlyService = new AeternityServiceFactory (). getService (); String callData = readOnlyService . compiler . blockingEncodeCalldata ( sourceCode , \"greet\" , Arrays . asList ( \"\\\"kryptokrauts\\\"\" ), null ) . getResult (); ContractCallTransactionModel contractCall = ContractCallTransactionModel . builder () . contractId ( contractId ) . callData ( callData ) . build (); DryRunTransactionResult dryRunResult = readOnlyService . transactions . blockingDryRunContractTx ( contractCall , true ); ObjectResultWrapper resultWrapper = readOnlyService . compiler . blockingDecodeCallResult ( sourceCode , \"greet\" , dryRunResult . getContractCallObject (). getReturnType (), dryRunResult . getContractCallObject (). getReturnValue (), null ); log . info ( resultWrapper . getResult (). toString ()); // \"Hello, kryptokrauts\"","title":"Explicit way"},{"location":"usage-guides/contracts.html#call-a-contract-stateful","text":"","title":"Call a contract (stateful)"},{"location":"usage-guides/contracts.html#convenient-way_2","text":"When using the convenient way by calling blockingStatefulContractCall you will receive an object ContractTxResult which includes all important information (e.g. tx-hash, gas used, ...) about the stateful contract call. ContractTxResult contractTxResult = aeternityService . transactions . blockingStatefulContractCall ( contractId , \"greet_and_remember\" , sourceCode , ContractTxOptions . builder () . params ( List . of ( new SophiaString ( \"kryptokrauts\" ))) . build ());","title":"Convenient way"},{"location":"usage-guides/contracts.html#explicit-way_2","text":"// obtain the calldata by calling the http compiler String callData = aeternityService . compiler . blockingEncodeCalldata ( chatBotSource , \"greet_and_remember\" , Arrays . asList ( \"\\\"kryptokrauts\\\"\" ), null ) . getResult (); // build the contract call tx model ContractCallTransactionModel contractCall = ContractCallTransactionModel . builder () . callerId ( aeternityService . keyPairAddress ) . contractId ( contractId ) . callData ( callData ) . nonce ( aeternityService . accounts . blockingGetNextNonce ()) . build (); /** * optional: if you know that the default of 25000 is sufficient you don't need a dry-run at all */ DryRunTransactionResult dryRunResult = aeternityService . transactions . blockingDryRunContractTx ( contractCall , false ); /** * determine gasUsed via dry-run and add a margin to make sure the tx gets mined. * ideally you implement this as a one-time action and monitor gas usage over time. * the margin is not required but recommended. if the provided gasLimit is insufficient * the tx will fail and consumed gas will be payed anyway. so you can lose funds */ BigInteger gasLimitWithMargin = new BigDecimal ( dryRunResult . getContractCallObject (). getGasUsed ()) . multiply ( new BigDecimal ( 1.5f )) . toBigInteger (); // set the gasLimitWithMargin before broadcasting the transaction contractCall = contractCall . toBuilder (). gasLimit ( gasLimitWithMargin ). build (); // broadcast the tx PostTransactionResult txResult = aeternityService . transactions . blockingPostTransaction ( contractCall ); // obtain the tx-info TransactionInfoResult infoResult = aeternityService . info . blockingGetTransactionInfoByHash ( txResult . getTxHash ()); // decode the return value by calling the http compiler ObjectResultWrapper resultWrapper = aeternityService . compiler . blockingDecodeCallResult ( chatBotSource , \"greet_and_remember\" , infoResult . getCallInfo (). getReturnType (), infoResult . getCallInfo (). getReturnValue (), null ); _logger . info ( resultWrapper . getResult (). toString ()); // \"Hello, kryptokrauts\"","title":"Explicit way"},{"location":"usage-guides/contracts.html#additional-topics","text":"","title":"Additional topics"},{"location":"usage-guides/contracts.html#gas-estimation-via-dry-run","text":"It is reasonable to estimate the gas consumption for a contract call using the dry-run feature of the node at least once and provide a specific offset (e.g. multiplied by 1.25 or 2) as default to ensure that contract calls are mined. Depending on the logic of the contract the gas consumption of a specific contract call can vary and therefore you should monitor the gas consumption and increase the default for the respective contract call accordingly over time. The default gas value of 25000 should cover all trivial stateful contract calls. In case transactions start running out of gas you should proceed the way described above and estimate the required gas using the dry-run feature.","title":"Gas estimation via dry-run"},{"location":"usage-guides/contracts.html#contracttxoptions","text":"In the convenience methods you can always provide tx-options and define some or all of following attributes: params (the list of params to be passed, default: null ) check the Sophia type-mapping table below amount (the amount in \u00e6ttos to be passed, default ZERO ) gasLimit (the custom gasLimit, default: 25000 ) gasPrice (the custom gasPrice to be used in the tx instead of the default 1000000000 ) nonce (the custom nonce to be used in the tx, default: automatically determined by the sdk) ttl (the custom ttl, default: ZERO ) filesystem (the includes-map for the contract, default: null ) key = include-name value = source code of the include","title":"ContractTxOptions"},{"location":"usage-guides/contracts.html#sophia-type-mapping","text":"The following mapping table indicates what Java types have to be passed for the respective Sophia entrypoint parameters. If you use the convenience methods you only need to make sure the params reflect the required types in Sophia. The convenience methods use the toCompilerInput method of SophiaTypeTransformer to automatically transform the Java type into the representation the Sophia compiler expects it to be. The reverse mapping not fully covered by the SDK. You need to analyze the result object and map/handle it accordingly. For some types there is also a reverse mapping implemented. To make use of this you have to call the getMappedResult method of the SophiaTypeTransformer and provide the expected type explicitely. If want full type support, please refer to the contraect-maven-plugin which will generate a class out of your contract with all types and methods under the hood to easily interact with your contract. Sophia type Java type Sophia example value address String ak_2gx9MEFxKvY9vMG5YnqnXWv1hCsX7rgnfvBLJS4aQurustR1rt bool Boolean true , false bytes(8) SophiaBytes #fedcba9876543210 Chain.ttl SophiaChainTTL FixedTTL(1050) , RelativeTTL(50) contract String ct_Ez6MyeTMm17YnTnDdHTSrzMEBKmy7Uz2sXu347bTDPgVH2ifJ hash SophiaHash #000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f int Integer / Long / BigInteger 1337 , 1337 list(string) List<SophiaString> [\"a\", \"b\", \"c\"] map(string, string) Map<SophiaString, SophiaString> {[\"foo\"] = \"bar\", [\"x\"] = \"yz\"} option(string) Optional<SophiaString> Some(\"kryptokrauts\") , None oracle('a, 'b) String ok_2YNyxd6TRJPNrTcEDCe9ra59SVUdp9FR9qWC5msKZWYD9bP9z5 oracle_query('a, 'b) String oq_2oRvyowJuJnEkxy58Ckkw77XfWJrmRgmGaLzhdqb67SKEL1gPY signature SophiaSignature #000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f string SophiaString \"This is a string\" tuple SophiaTuple (42, \"Foo\", true)","title":"Sophia type-mapping"},{"location":"usage-guides/contracts.html#plugins","text":"","title":"Plugins"},{"location":"usage-guides/contracts.html#contraect-maven-plugin","text":"To provide an even more convenient way to interact with smart contracts on the \u00e6ternity blockchain we developed a plugin that uses the ACI of contracts written in Sophia as input to generate Java classes. The generated classes make use of the aepp-sdk-java and provide methods to deploy contracts and call the respective entrypoint functions. In contrast to plain SDK usage the plugin provides you type-safe param and return values. Links : https://github.com/kryptokrauts/contraect-maven-plugin https://github.com/kryptokrauts/contraect-showcase-maven","title":"contraect-maven-plugin"},{"location":"usage-guides/ga.html","text":"Generalized Accounts Introduction Generalized Accounts (GAs) are mainly a way to give more flexibility when it comes to transaction integrity, in particular when it comes to signing. This is done by moving both the nonce handling and signature checking to a smart contract that is attached to the account. Example ECDSAAuth contract The following contract can be used in order to make the \u00e6ternity account a GA that expects transactions to be signed with the Elliptic Curve Digital Signature Algorithm known from Ethereum. This way you can for example use your Ethereum private key in order to sign transactions on \u00e6ternity. contract ECDSAAuth = record state = { nonce : int , owner : bytes ( 20 ) } entrypoint init ( owner' : bytes ( 20 )) = { nonce = 1 , owner = owner' } stateful entrypoint authorize ( n : int , s : bytes ( 65 )) : bool = require ( n >= state . nonce , \"Nonce too low\" ) require ( n =< state . nonce , \"Nonce too high\" ) put ( state { nonce = n + 1 }) switch ( Auth . tx_hash ) None => abort ( \"Not in Auth context\" ) Some ( tx_hash ) => Crypto . ecverify_secp256k1 ( to_sign ( tx_hash , n ), state . owner , s ) entrypoint to_sign ( h : hash , n : int ) : hash = Crypto . blake2b (( h , n )) entrypoint get_nonce () : int = state . nonce entrypoint get_owner () : bytes ( 20 ) = state . owner Attach the Generalized Account Before actually being able to use the Ethereum private key for signing you have to first attach the contract to the account which makes it a GA. Following code snippet shows how to achieve this: String ecdsaAuthSource = \"...\" ; String ethereumAddress = \"...\" ; AccountResult gaTestAccount = aeternityService . accounts . blockingGetAccount ( gaAccountKeyPair . getAddress ()); log . info ( gaTestAccount . toString ()); // AccountResult(publicKey=ak_2V4Sgh4FRBaAGox9pkFgYBKFGjf4kKxyMumiT9RcvCCeSFiTpS, balance=10000000000000000000, nonce=0, payable=true, kind=basic, gaContractId=null, gaAuthenticationFunction=null) // Ethereum address as bytes(20) in Sophia String expectedEthereumAddress = ethereumAddress . replace ( \"0x\" , \"#\" ); // encode the required calldata via http compiler StringResultWrapper resultWrapper = aeternityService . compiler . blockingEncodeCalldata ( ecdsaAuthSource , \"init\" , SophiaTypeTransformer . toCompilerInput ( List . of ( new SophiaBytes ( expectedEthereumAddress , 20 ))), null ); String callData = resultWrapper . getResult (); // get bytecode via http compiler resultWrapper = aeternityService . compiler . blockingCompile ( ecdsaAuthSource , null ); String code = resultWrapper . getResult (); // build the GAAttachTx GeneralizedAccountsAttachTransactionModel gaAttachTx = GeneralizedAccountsAttachTransactionModel . builder () . authFun ( EncodingUtils . generateAuthFunHash ( \"authorize\" )) . callData ( callData ) . code ( code ) . nonce ( gaTestAccount . getNonce (). add ( ONE )) . ownerId ( gaTestAccount . getPublicKey ()) . build (); // broadcast the tx to attach the GA aeternityService . transactions . blockingPostTransaction ( gaAttachTx , gaAccountKeyPair . getEncodedPrivateKey ()); gaTestAccount = aeternityService . accounts . blockingGetAccount ( gaAccountKeyPair . getAddress ()); log . info ( gaTestAccount . toString ()); // AccountResult(publicKey=ak_2V4Sgh4FRBaAGox9pkFgYBKFGjf4kKxyMumiT9RcvCCeSFiTpS, balance=9999915897000000000, nonce=1, payable=true, kind=generalized, gaContractId=ct_2m5omoYZCRMf4as85V6FW3LDENoBM4JnHgMoPKk6Xz41tb6617, gaAuthenticationFunction=authorize) Congratulations, you now have a GA and can sign transactions with your Ethereum private key! Attention: Be aware, there is no way back if you made your account a GA! Perform a meta transaction for the GA Once the GA is attached you can perform a GaMetaTx . The GaMetaTx can include any type of tx supported by the \u00e6ternity protocol. In this specific example we perform a simple SpendTx . The important part is how to produce the right hash of the tx in combination with the nonce which needs to be signed. For this specific example a Sophia encoded tuple of a hash and an integer, which is also hashed, needs to be signed. As this is not trivial we use the dry-run functionality of the node to get the correct hash from the contract by providing the tx-hash and the nonce in order to achieve that. Note: To simplify this you could also just hash a concatenated String of tx-hash and nonce ;-) // send 1 AE UnitConversionService unitConversionService = new DefaultUnitConversionServiceImpl (); BigInteger amountToSend = unitConversionService . toSmallestUnit ( \"1\" ); // create a new KeyPair for the recipient KeyPair otherRecipient = keyPairService . generateKeyPair (); // build the inner SpendTx to be included in the GaMetaTx SpendTransactionModel gaInnerSpendTx = SpendTransactionModel . builder () . sender ( gaAccountKeyPair . getAddress ()) . recipient ( otherRecipient . getAddress ()) . amount ( amountToSend ) . payload ( \"spent using a generalized account with Ethereum signature =)\" ) . nonce ( ZERO ) // GA inner tx requires 0 as nonce . build (); // compute the correct hash for the inner tx String txHash = aeternityService . transactions . computeGAInnerTxHash ( gaInnerSpendTx ); // call the \"to_sign\" entrypoint to get the correct hash to sign from the contract Object toSignResult = aeternityService . transactions . blockingReadOnlyContractCall ( gaTestAccount . getGaContractId (), \"to_sign\" , ecdsaAuthSource , ContractTxOptions . builder (). params ( List . of ( new SophiaHash ( txHash ), 1 )) . build ()); // remove the Sophia prefix \"#\" from the hash and decode it byte [] toSign = Hex . decode ( toSignResult . toString (). substring ( 1 )); // sign the hash e.g. using web3j byte [] signedTxHashWithNonce = web3jSignMessage ( toSign , credentials . getEcKeyPair ()); // encode the require authData using the http compiler String authData = this . aeternityService . compiler . blockingEncodeCalldata ( ecdsaAuthSource , \"authorize\" , SophiaTypeTransformer . toCompilerInput ( List . of ( 1 , new SophiaBytes ( Hex . toHexString ( signedTxHashWithNonce ), 65 ))), null ) . getResult (); // build the GaMetaTx GeneralizedAccountsMetaTransactionModel gaMetaTx = GeneralizedAccountsMetaTransactionModel . builder () . gaId ( gaAccountKeyPair . getAddress ()) . authData ( authData ) . innerTxModel ( gaInnerSpendTx ) . build (); // broadcast the tx aeternityService . transactions . blockingPostTransaction ( gaMetaTx ); Additional examples We also created a simple GaMultiSig example in our contract-maven-showcase repository.","title":"Generalized Accounts"},{"location":"usage-guides/ga.html#generalized-accounts","text":"","title":"Generalized Accounts"},{"location":"usage-guides/ga.html#introduction","text":"Generalized Accounts (GAs) are mainly a way to give more flexibility when it comes to transaction integrity, in particular when it comes to signing. This is done by moving both the nonce handling and signature checking to a smart contract that is attached to the account.","title":"Introduction"},{"location":"usage-guides/ga.html#example","text":"","title":"Example"},{"location":"usage-guides/ga.html#ecdsaauth-contract","text":"The following contract can be used in order to make the \u00e6ternity account a GA that expects transactions to be signed with the Elliptic Curve Digital Signature Algorithm known from Ethereum. This way you can for example use your Ethereum private key in order to sign transactions on \u00e6ternity. contract ECDSAAuth = record state = { nonce : int , owner : bytes ( 20 ) } entrypoint init ( owner' : bytes ( 20 )) = { nonce = 1 , owner = owner' } stateful entrypoint authorize ( n : int , s : bytes ( 65 )) : bool = require ( n >= state . nonce , \"Nonce too low\" ) require ( n =< state . nonce , \"Nonce too high\" ) put ( state { nonce = n + 1 }) switch ( Auth . tx_hash ) None => abort ( \"Not in Auth context\" ) Some ( tx_hash ) => Crypto . ecverify_secp256k1 ( to_sign ( tx_hash , n ), state . owner , s ) entrypoint to_sign ( h : hash , n : int ) : hash = Crypto . blake2b (( h , n )) entrypoint get_nonce () : int = state . nonce entrypoint get_owner () : bytes ( 20 ) = state . owner","title":"ECDSAAuth contract"},{"location":"usage-guides/ga.html#attach-the-generalized-account","text":"Before actually being able to use the Ethereum private key for signing you have to first attach the contract to the account which makes it a GA. Following code snippet shows how to achieve this: String ecdsaAuthSource = \"...\" ; String ethereumAddress = \"...\" ; AccountResult gaTestAccount = aeternityService . accounts . blockingGetAccount ( gaAccountKeyPair . getAddress ()); log . info ( gaTestAccount . toString ()); // AccountResult(publicKey=ak_2V4Sgh4FRBaAGox9pkFgYBKFGjf4kKxyMumiT9RcvCCeSFiTpS, balance=10000000000000000000, nonce=0, payable=true, kind=basic, gaContractId=null, gaAuthenticationFunction=null) // Ethereum address as bytes(20) in Sophia String expectedEthereumAddress = ethereumAddress . replace ( \"0x\" , \"#\" ); // encode the required calldata via http compiler StringResultWrapper resultWrapper = aeternityService . compiler . blockingEncodeCalldata ( ecdsaAuthSource , \"init\" , SophiaTypeTransformer . toCompilerInput ( List . of ( new SophiaBytes ( expectedEthereumAddress , 20 ))), null ); String callData = resultWrapper . getResult (); // get bytecode via http compiler resultWrapper = aeternityService . compiler . blockingCompile ( ecdsaAuthSource , null ); String code = resultWrapper . getResult (); // build the GAAttachTx GeneralizedAccountsAttachTransactionModel gaAttachTx = GeneralizedAccountsAttachTransactionModel . builder () . authFun ( EncodingUtils . generateAuthFunHash ( \"authorize\" )) . callData ( callData ) . code ( code ) . nonce ( gaTestAccount . getNonce (). add ( ONE )) . ownerId ( gaTestAccount . getPublicKey ()) . build (); // broadcast the tx to attach the GA aeternityService . transactions . blockingPostTransaction ( gaAttachTx , gaAccountKeyPair . getEncodedPrivateKey ()); gaTestAccount = aeternityService . accounts . blockingGetAccount ( gaAccountKeyPair . getAddress ()); log . info ( gaTestAccount . toString ()); // AccountResult(publicKey=ak_2V4Sgh4FRBaAGox9pkFgYBKFGjf4kKxyMumiT9RcvCCeSFiTpS, balance=9999915897000000000, nonce=1, payable=true, kind=generalized, gaContractId=ct_2m5omoYZCRMf4as85V6FW3LDENoBM4JnHgMoPKk6Xz41tb6617, gaAuthenticationFunction=authorize) Congratulations, you now have a GA and can sign transactions with your Ethereum private key! Attention: Be aware, there is no way back if you made your account a GA!","title":"Attach the Generalized Account"},{"location":"usage-guides/ga.html#perform-a-meta-transaction-for-the-ga","text":"Once the GA is attached you can perform a GaMetaTx . The GaMetaTx can include any type of tx supported by the \u00e6ternity protocol. In this specific example we perform a simple SpendTx . The important part is how to produce the right hash of the tx in combination with the nonce which needs to be signed. For this specific example a Sophia encoded tuple of a hash and an integer, which is also hashed, needs to be signed. As this is not trivial we use the dry-run functionality of the node to get the correct hash from the contract by providing the tx-hash and the nonce in order to achieve that. Note: To simplify this you could also just hash a concatenated String of tx-hash and nonce ;-) // send 1 AE UnitConversionService unitConversionService = new DefaultUnitConversionServiceImpl (); BigInteger amountToSend = unitConversionService . toSmallestUnit ( \"1\" ); // create a new KeyPair for the recipient KeyPair otherRecipient = keyPairService . generateKeyPair (); // build the inner SpendTx to be included in the GaMetaTx SpendTransactionModel gaInnerSpendTx = SpendTransactionModel . builder () . sender ( gaAccountKeyPair . getAddress ()) . recipient ( otherRecipient . getAddress ()) . amount ( amountToSend ) . payload ( \"spent using a generalized account with Ethereum signature =)\" ) . nonce ( ZERO ) // GA inner tx requires 0 as nonce . build (); // compute the correct hash for the inner tx String txHash = aeternityService . transactions . computeGAInnerTxHash ( gaInnerSpendTx ); // call the \"to_sign\" entrypoint to get the correct hash to sign from the contract Object toSignResult = aeternityService . transactions . blockingReadOnlyContractCall ( gaTestAccount . getGaContractId (), \"to_sign\" , ecdsaAuthSource , ContractTxOptions . builder (). params ( List . of ( new SophiaHash ( txHash ), 1 )) . build ()); // remove the Sophia prefix \"#\" from the hash and decode it byte [] toSign = Hex . decode ( toSignResult . toString (). substring ( 1 )); // sign the hash e.g. using web3j byte [] signedTxHashWithNonce = web3jSignMessage ( toSign , credentials . getEcKeyPair ()); // encode the require authData using the http compiler String authData = this . aeternityService . compiler . blockingEncodeCalldata ( ecdsaAuthSource , \"authorize\" , SophiaTypeTransformer . toCompilerInput ( List . of ( 1 , new SophiaBytes ( Hex . toHexString ( signedTxHashWithNonce ), 65 ))), null ) . getResult (); // build the GaMetaTx GeneralizedAccountsMetaTransactionModel gaMetaTx = GeneralizedAccountsMetaTransactionModel . builder () . gaId ( gaAccountKeyPair . getAddress ()) . authData ( authData ) . innerTxModel ( gaInnerSpendTx ) . build (); // broadcast the tx aeternityService . transactions . blockingPostTransaction ( gaMetaTx );","title":"Perform a meta transaction for the GA"},{"location":"usage-guides/ga.html#additional-examples","text":"We also created a simple GaMultiSig example in our contract-maven-showcase repository.","title":"Additional examples"},{"location":"usage-guides/mdw.html","text":"Middleware The aeternity middleware extends the node and exposes their own websocket and http api. Certain information such as AENS auction data cannot be directly fetched from the node. Thus you will have to communicate with the mdw to get access to this data. At the moment the MiddlewareService only provides functions to get AENS auction relevant data. If you need convenient access to any other specific API endpoint feel free to open an issue . AENS Get a specific auction String aensName = \"xyz.chain\" ; NameAuctionResult nameAuctionResult = aeternityService . mdw . blockingGetNameAuction ( aensName ); Get all auctions NameAuctionsResult nameAuctionsResult = aeternityService . mdw . blockingGetNameAuctions ();","title":"Middleware"},{"location":"usage-guides/mdw.html#middleware","text":"The aeternity middleware extends the node and exposes their own websocket and http api. Certain information such as AENS auction data cannot be directly fetched from the node. Thus you will have to communicate with the mdw to get access to this data. At the moment the MiddlewareService only provides functions to get AENS auction relevant data. If you need convenient access to any other specific API endpoint feel free to open an issue .","title":"Middleware"},{"location":"usage-guides/mdw.html#aens","text":"","title":"AENS"},{"location":"usage-guides/mdw.html#get-a-specific-auction","text":"String aensName = \"xyz.chain\" ; NameAuctionResult nameAuctionResult = aeternityService . mdw . blockingGetNameAuction ( aensName );","title":"Get a specific auction"},{"location":"usage-guides/mdw.html#get-all-auctions","text":"NameAuctionsResult nameAuctionsResult = aeternityService . mdw . blockingGetNameAuctions ();","title":"Get all auctions"},{"location":"usage-guides/oracles.html","text":"Oracles Introduction This guide shows you how to perform all the operations that you need within the lifecycle of oracles using the SDK. 1. Oracle: register You register an oracle that responds with the temperature of the city that is included in the query. This guide uses an example response of https://api.openweathermap.org . KeyPair oracleKeyPair = ... BigInteger nonce = aeternityService . accounts . blockingGetNextNonce ( oracleKeyPair . getAddress ()); OracleRegisterTransactionModel oracleRegisterTx = OracleRegisterTransactionModel . builder () . accountId ( oracleKeyPair . getAddress ()) . nonce ( nonce ) // lives for 5000 keyblocks if it isn't extended . oracleTtl ( BigInteger . valueOf ( 5000 )) // using delta instead of fixed block height . oracleTtlType ( OracleTTLType . DELTA ) // fee in aettos a caller needs to pay . queryFee ( BigInteger . valueOf ( 100 )) . queryFormat ( \"string\" ) . responseFormat ( \"string\" ) . build (); aeternityService . transactions . blockingPostTransaction ( oracleRegisterTx , oracleKeyPair . getEncodedPrivateKey ()); Note: By default the oracle will exist for the next 5000 KeyBlocks. If you intend to keep your oracle running longer you should increase the oracleTtl and/or set up a service that automatically extends the TTL before it expires. The oracleId will be similar to the address of the account that registered the Oracle. The only difference is the prefix that will be ok_ instead of ak_ This means that each account can only host 1 oracle. It's not possible to manage multiple oracles using the same account. 2. Some party: query an oracle and poll for response Query After the oracle has been registered and as long as it isn't expired, everybody that knows the oracleId can query it. KeyPair callerKeyPair = ... BigInteger nonce = aeternityService . accounts . blockingGetNextNonce ( callerKeyPair . getAddress ()); String oracleId = \"ok_...\" ; String queryString = \"{\\\"lat\\\":48.78,\\\"lon\\\":9.18}\" ; OracleQueryTransactionModel oracleQueryTx = OracleQueryTransactionModel . builder () . senderId ( callerKeyPair . getAddress ()) . oracleId ( oracleId ) . nonce ( nonce ) . query ( queryString ) // fee needs to fit the fee defined by the oracle . queryFee ( BigInteger . valueOf ( 100 )) // oracle can respond within the next 50 keyblocks . queryTtl ( BigInteger . valueOf ( 50 )) . queryTtlType ( OracleTTLType . DELTA ) // response will be available 100 keyblocks // before being garbage collected together with the query . responseTtl ( BigInteger . valueOf ( 100 )) . build (); aeternityService . transactions . blockingPostTransaction ( oracleQueryTx , callerKeyPair . getEncodedPrivateKey ()); Note: You should fetch (or know) the required fee for the query to the oracle. If you don't provide a sufficient fee the transaction is invalid. Poll for response After broadcasting the OracleQueryTx you can poll for the response to that specific query like this: // using the same nonce and oracleId as like in the OracleQueryTx String queryId = EncodingUtils . queryId ( callerKeyPair . getAddress (), nonce , oracleId ); String response = null ; // wait for the response while ( response == null || response . isEmpty ()) { OracleQueryResult oracleQueryResult = this . aeternityService . oracles . blockingGetOracleQuery ( oracleId , queryId ); response = oracleQueryResult . getResponse (); } // do something with the response Note: The OracleQueryResult will only contain the response property if the Oracle responded. 3. Oracle: poll for queries and respond Poll for queries & respond Typically the oracle itself polls for its own queries and responds as soon as possible: // fetch oracle queries OracleQueriesResult oracleQueriesResult = this . aeternityService . oracles . blockingGetOracleQueries ( oracleKeyPair . getOracleAddress ()); // typically the oracle would respond to all queries it didn't already respond to // in this case it only responds to the first query in the list OracleQueryResult oracleQueryResult = oracleQueriesResult . getQueryResults (). get ( 0 ); String responseString = \"{\\\"coord\\\":{\\\"lon\\\":9.18,\\\"lat\\\":48.78},\\\"weather\\\":[{\\\"id\\\":310,\\\"main\\\":\\\"Drizzle\\\",\\\"description\\\":\\\"light intensity drizzle rain\\\",\\\"icon\\\":\\\"09n\\\"}],\\\"base\\\":\\\"stations\\\",\\\"main\\\":{\\\"temp\\\":282.56,\\\"pressure\\\":1021,\\\"humidity\\\":93,\\\"temp_min\\\":279.82,\\\"temp_max\\\":285.37},\\\"visibility\\\":7000,\\\"wind\\\":{\\\"speed\\\":4.1,\\\"deg\\\":330},\\\"clouds\\\":{\\\"all\\\":90},\\\"dt\\\":1572217099,\\\"sys\\\":{\\\"type\\\":1,\\\"id\\\":1274,\\\"country\\\":\\\"DE\\\",\\\"sunrise\\\":1572156074,\\\"sunset\\\":1572192774},\\\"timezone\\\":3600,\\\"id\\\":2825297,\\\"name\\\":\\\"Stuttgart\\\",\\\"cod\\\":200}\" ; BigInteger nonce = aeternityService . accounts . blockingGetNextNonce ( oracleKeyPair . getAddress ()); OracleRespondTransactionModel oracleRespondTx = OracleRespondTransactionModel . builder () . oracleId ( oracleKeyPair . getOracleAddress ()) . queryId ( oracleQueryResult . getId ()) . nonce ( nonce ) . response ( responseString ) . responseTtl ( BigInteger . valueOf ( 100 )) . build (); aeternityService . transactions . blockingPostTransaction ( oracleRespondTx , oracleKeyPair . getEncodedPrivateKey ()); Note: The oracle itself would probably either use an API to get the current temperature for a certain city or ideally directly communicate with measuring devices located in that specific city. If the oracle responds in time it will automatically get the provided query fee credited to its account. 4. Oracle: extend As mentioned above an Oracle has a certain TTL that can be specified when registering it. You might want to extend the TTL of the oracle before it expires. You can do that as follows: BigInteger nonce = aeternityService . accounts . blockingGetNextNonce ( oracleKeyPair . getAddress ()); OracleExtendTransactionModel oracleExtendTx = OracleExtendTransactionModel . builder () . nonce ( nonce ) . oracleId ( oracleKeyPair . getOracleAddress ()) // extend the oracle ttl for another 100 keyblocks . relativeTtl ( BigInteger . valueOf ( 100 )) . build (); aeternityService . transactions . blockingPostTransaction ( oracleExtendTx , oracleKeyPair . getEncodedPrivateKey ()); Delegate signature to contract (Oracle interface) It is possible to authorize a Sophia contract to manage an Oracle on behalf of your account. In order to achieve that you need to provide a delegation signature to the contract. The contract will then be able to use the Oracle interface and perform Oracle related actions on behalf of your account. This functionality could for example be used to build an AENS marketplace. The DelegationService can be used to produce the signatures that can be used to delegate control for certain actions to a smart contract. Examples how to delegate signatures to a contract can be found in our contract-maven-showcase .","title":"Oracles"},{"location":"usage-guides/oracles.html#oracles","text":"","title":"Oracles"},{"location":"usage-guides/oracles.html#introduction","text":"This guide shows you how to perform all the operations that you need within the lifecycle of oracles using the SDK.","title":"Introduction"},{"location":"usage-guides/oracles.html#1-oracle-register","text":"You register an oracle that responds with the temperature of the city that is included in the query. This guide uses an example response of https://api.openweathermap.org . KeyPair oracleKeyPair = ... BigInteger nonce = aeternityService . accounts . blockingGetNextNonce ( oracleKeyPair . getAddress ()); OracleRegisterTransactionModel oracleRegisterTx = OracleRegisterTransactionModel . builder () . accountId ( oracleKeyPair . getAddress ()) . nonce ( nonce ) // lives for 5000 keyblocks if it isn't extended . oracleTtl ( BigInteger . valueOf ( 5000 )) // using delta instead of fixed block height . oracleTtlType ( OracleTTLType . DELTA ) // fee in aettos a caller needs to pay . queryFee ( BigInteger . valueOf ( 100 )) . queryFormat ( \"string\" ) . responseFormat ( \"string\" ) . build (); aeternityService . transactions . blockingPostTransaction ( oracleRegisterTx , oracleKeyPair . getEncodedPrivateKey ()); Note: By default the oracle will exist for the next 5000 KeyBlocks. If you intend to keep your oracle running longer you should increase the oracleTtl and/or set up a service that automatically extends the TTL before it expires. The oracleId will be similar to the address of the account that registered the Oracle. The only difference is the prefix that will be ok_ instead of ak_ This means that each account can only host 1 oracle. It's not possible to manage multiple oracles using the same account.","title":"1. Oracle: register"},{"location":"usage-guides/oracles.html#2-some-party-query-an-oracle-and-poll-for-response","text":"","title":"2. Some party: query an oracle and poll for response"},{"location":"usage-guides/oracles.html#query","text":"After the oracle has been registered and as long as it isn't expired, everybody that knows the oracleId can query it. KeyPair callerKeyPair = ... BigInteger nonce = aeternityService . accounts . blockingGetNextNonce ( callerKeyPair . getAddress ()); String oracleId = \"ok_...\" ; String queryString = \"{\\\"lat\\\":48.78,\\\"lon\\\":9.18}\" ; OracleQueryTransactionModel oracleQueryTx = OracleQueryTransactionModel . builder () . senderId ( callerKeyPair . getAddress ()) . oracleId ( oracleId ) . nonce ( nonce ) . query ( queryString ) // fee needs to fit the fee defined by the oracle . queryFee ( BigInteger . valueOf ( 100 )) // oracle can respond within the next 50 keyblocks . queryTtl ( BigInteger . valueOf ( 50 )) . queryTtlType ( OracleTTLType . DELTA ) // response will be available 100 keyblocks // before being garbage collected together with the query . responseTtl ( BigInteger . valueOf ( 100 )) . build (); aeternityService . transactions . blockingPostTransaction ( oracleQueryTx , callerKeyPair . getEncodedPrivateKey ()); Note: You should fetch (or know) the required fee for the query to the oracle. If you don't provide a sufficient fee the transaction is invalid.","title":"Query"},{"location":"usage-guides/oracles.html#poll-for-response","text":"After broadcasting the OracleQueryTx you can poll for the response to that specific query like this: // using the same nonce and oracleId as like in the OracleQueryTx String queryId = EncodingUtils . queryId ( callerKeyPair . getAddress (), nonce , oracleId ); String response = null ; // wait for the response while ( response == null || response . isEmpty ()) { OracleQueryResult oracleQueryResult = this . aeternityService . oracles . blockingGetOracleQuery ( oracleId , queryId ); response = oracleQueryResult . getResponse (); } // do something with the response Note: The OracleQueryResult will only contain the response property if the Oracle responded.","title":"Poll for response"},{"location":"usage-guides/oracles.html#3-oracle-poll-for-queries-and-respond","text":"","title":"3. Oracle: poll for queries and respond"},{"location":"usage-guides/oracles.html#poll-for-queries-respond","text":"Typically the oracle itself polls for its own queries and responds as soon as possible: // fetch oracle queries OracleQueriesResult oracleQueriesResult = this . aeternityService . oracles . blockingGetOracleQueries ( oracleKeyPair . getOracleAddress ()); // typically the oracle would respond to all queries it didn't already respond to // in this case it only responds to the first query in the list OracleQueryResult oracleQueryResult = oracleQueriesResult . getQueryResults (). get ( 0 ); String responseString = \"{\\\"coord\\\":{\\\"lon\\\":9.18,\\\"lat\\\":48.78},\\\"weather\\\":[{\\\"id\\\":310,\\\"main\\\":\\\"Drizzle\\\",\\\"description\\\":\\\"light intensity drizzle rain\\\",\\\"icon\\\":\\\"09n\\\"}],\\\"base\\\":\\\"stations\\\",\\\"main\\\":{\\\"temp\\\":282.56,\\\"pressure\\\":1021,\\\"humidity\\\":93,\\\"temp_min\\\":279.82,\\\"temp_max\\\":285.37},\\\"visibility\\\":7000,\\\"wind\\\":{\\\"speed\\\":4.1,\\\"deg\\\":330},\\\"clouds\\\":{\\\"all\\\":90},\\\"dt\\\":1572217099,\\\"sys\\\":{\\\"type\\\":1,\\\"id\\\":1274,\\\"country\\\":\\\"DE\\\",\\\"sunrise\\\":1572156074,\\\"sunset\\\":1572192774},\\\"timezone\\\":3600,\\\"id\\\":2825297,\\\"name\\\":\\\"Stuttgart\\\",\\\"cod\\\":200}\" ; BigInteger nonce = aeternityService . accounts . blockingGetNextNonce ( oracleKeyPair . getAddress ()); OracleRespondTransactionModel oracleRespondTx = OracleRespondTransactionModel . builder () . oracleId ( oracleKeyPair . getOracleAddress ()) . queryId ( oracleQueryResult . getId ()) . nonce ( nonce ) . response ( responseString ) . responseTtl ( BigInteger . valueOf ( 100 )) . build (); aeternityService . transactions . blockingPostTransaction ( oracleRespondTx , oracleKeyPair . getEncodedPrivateKey ()); Note: The oracle itself would probably either use an API to get the current temperature for a certain city or ideally directly communicate with measuring devices located in that specific city. If the oracle responds in time it will automatically get the provided query fee credited to its account.","title":"Poll for queries &amp; respond"},{"location":"usage-guides/oracles.html#4-oracle-extend","text":"As mentioned above an Oracle has a certain TTL that can be specified when registering it. You might want to extend the TTL of the oracle before it expires. You can do that as follows: BigInteger nonce = aeternityService . accounts . blockingGetNextNonce ( oracleKeyPair . getAddress ()); OracleExtendTransactionModel oracleExtendTx = OracleExtendTransactionModel . builder () . nonce ( nonce ) . oracleId ( oracleKeyPair . getOracleAddress ()) // extend the oracle ttl for another 100 keyblocks . relativeTtl ( BigInteger . valueOf ( 100 )) . build (); aeternityService . transactions . blockingPostTransaction ( oracleExtendTx , oracleKeyPair . getEncodedPrivateKey ());","title":"4. Oracle: extend"},{"location":"usage-guides/oracles.html#delegate-signature-to-contract-oracle-interface","text":"It is possible to authorize a Sophia contract to manage an Oracle on behalf of your account. In order to achieve that you need to provide a delegation signature to the contract. The contract will then be able to use the Oracle interface and perform Oracle related actions on behalf of your account. This functionality could for example be used to build an AENS marketplace. The DelegationService can be used to produce the signatures that can be used to delegate control for certain actions to a smart contract. Examples how to delegate signatures to a contract can be found in our contract-maven-showcase .","title":"Delegate signature to contract (Oracle interface)"},{"location":"usage-guides/payingfortx.html","text":"PayingForTx Introduction This guide explains you how to perform a PayingForTx (also known as meta-transaction) using this SDK. It is a very powerful and efficient solution that is for example crucial for onboarding new users into the \u00e6ternity ecosystem. By making use of the PayingForTx you will be able to cover the fees of your users. How it works Typically somebody that you want to pay the transaction for (e.g. a new user of your decentralized aepp) signs the inner transaction (e.g. of type ContractCallTx ) with a specific signature that is used for inner transactions. You can then collect the signed inner transaction, wrap it into a PayingForTx and broadcast it to the network. SpendTx in PayingForTx This is an example how one can cover the transaction fee for another account that simply wants to send some AE: KeyPair senderWhoDelegates = ... KeyPair recipient = ... KeyPair payerDelegate = ... BigInteger senderNonce = aeternityService . accounts . blockingGetNextNonce ( senderWhoDelegates . getAddress ()); SpendTransactionModel spendTx = SpendTransactionModel . builder () . sender ( senderWhoDelegates . getAddress ()) . recipient ( anotherKeypair . getAddress ()) . amount ( amount ) . payload ( \"yeah, somebody else payed the tx fee for this transaction =)\" ) . nonce ( senderNonce ) . build (); // the inner tx of a PayingForTx needs to be signed with a specific prefix // the sdk provides the respective method to do this String signedInnerTx = aeternityService . transactions . signPayingForInnerTransaction ( spendTx , senderWhoDelegates . getEncodedPrivateKey ()); BigInteger payerNonce = aeternityService . accounts . blockingGetNextNonce ( payerDelegate . getAddress ()); PayingForTransactionModel payingForTx = PayingForTransactionModel . builder () . payerId ( payerDelegate ) . nonce ( payerNonce ) . innerTx ( signedInnerTx ) . build (); aeternityService . transactions . blockingPostTransaction ( payingForTx ); Note: This can be done for any tx-type! In the example we assume that the wrapped inner tx is built and signed by a user that interacts with an aepp. The aepp sends the signed transaction to the Java backend which wraps it into PayingForTx and pays the required fee. You can even combine the usage of a Generalized Account with the PayingForTx which provides lots of possiblities! Contract calls in PayingForTx If you need to onboard users that don't have any funds you can pay the fee of their contract calls using the PayingForTx . This way your aepp can hide some complexity of using the underlying blockchain and your users don't have to buy AE in order to use your aepp! Use cases Game developers that want to quickly onboard new users. Governance aepps that want people to vote on important proposals without having them to pay anything. Custodians that want to offer an additional services to cover the transaction fees of their clients. ... many more!","title":"PayingForTx"},{"location":"usage-guides/payingfortx.html#payingfortx","text":"","title":"PayingForTx"},{"location":"usage-guides/payingfortx.html#introduction","text":"This guide explains you how to perform a PayingForTx (also known as meta-transaction) using this SDK. It is a very powerful and efficient solution that is for example crucial for onboarding new users into the \u00e6ternity ecosystem. By making use of the PayingForTx you will be able to cover the fees of your users.","title":"Introduction"},{"location":"usage-guides/payingfortx.html#how-it-works","text":"Typically somebody that you want to pay the transaction for (e.g. a new user of your decentralized aepp) signs the inner transaction (e.g. of type ContractCallTx ) with a specific signature that is used for inner transactions. You can then collect the signed inner transaction, wrap it into a PayingForTx and broadcast it to the network.","title":"How it works"},{"location":"usage-guides/payingfortx.html#spendtx-in-payingfortx","text":"This is an example how one can cover the transaction fee for another account that simply wants to send some AE: KeyPair senderWhoDelegates = ... KeyPair recipient = ... KeyPair payerDelegate = ... BigInteger senderNonce = aeternityService . accounts . blockingGetNextNonce ( senderWhoDelegates . getAddress ()); SpendTransactionModel spendTx = SpendTransactionModel . builder () . sender ( senderWhoDelegates . getAddress ()) . recipient ( anotherKeypair . getAddress ()) . amount ( amount ) . payload ( \"yeah, somebody else payed the tx fee for this transaction =)\" ) . nonce ( senderNonce ) . build (); // the inner tx of a PayingForTx needs to be signed with a specific prefix // the sdk provides the respective method to do this String signedInnerTx = aeternityService . transactions . signPayingForInnerTransaction ( spendTx , senderWhoDelegates . getEncodedPrivateKey ()); BigInteger payerNonce = aeternityService . accounts . blockingGetNextNonce ( payerDelegate . getAddress ()); PayingForTransactionModel payingForTx = PayingForTransactionModel . builder () . payerId ( payerDelegate ) . nonce ( payerNonce ) . innerTx ( signedInnerTx ) . build (); aeternityService . transactions . blockingPostTransaction ( payingForTx ); Note: This can be done for any tx-type! In the example we assume that the wrapped inner tx is built and signed by a user that interacts with an aepp. The aepp sends the signed transaction to the Java backend which wraps it into PayingForTx and pays the required fee. You can even combine the usage of a Generalized Account with the PayingForTx which provides lots of possiblities!","title":"SpendTx in PayingForTx"},{"location":"usage-guides/payingfortx.html#contract-calls-in-payingfortx","text":"If you need to onboard users that don't have any funds you can pay the fee of their contract calls using the PayingForTx . This way your aepp can hide some complexity of using the underlying blockchain and your users don't have to buy AE in order to use your aepp!","title":"Contract calls in PayingForTx"},{"location":"usage-guides/payingfortx.html#use-cases","text":"Game developers that want to quickly onboard new users. Governance aepps that want people to vote on important proposals without having them to pay anything. Custodians that want to offer an additional services to cover the transaction fees of their clients. ... many more!","title":"Use cases"}]}